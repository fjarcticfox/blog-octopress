<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：operation System | 逆水行舟]]></title>
  <link href="http://blog.longgen.me/blog/categories/operation-system/atom.xml" rel="self"/>
  <link href="http://blog.longgen.me/"/>
  <updated>2014-07-01T15:16:51+08:00</updated>
  <id>http://blog.longgen.me/</id>
  <author>
    <name><![CDATA[Longgen]]></name>
    <email><![CDATA[fjarcticfox@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ubuntu 软件安装与卸载]]></title>
    <link href="http://blog.longgen.me/blog/2014/06/27/ubuntu-ruan-jian-an-zhuang-yu-xie-zai/"/>
    <updated>2014-06-27T11:56:37+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/06/27/ubuntu-ruan-jian-an-zhuang-yu-xie-zai</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>软件包的安装、卸载</h2>

<h3>软件包的安装</h3>

<ul>
<li>APT 方式</li>
</ul>


<p>```sh</p>

<h1>普通安装</h1>

<p>apt-get install softname1 softname2 &hellip;;</p>

<h1>修复安装（-f Atemp to correct broken dependencies）</h1>

<p>apt-get -f install softname1 softname2 &hellip;;</p>

<h1>重新安装</h1>

<p>apt-get &mdash;reinstall install softname1 softname2 &hellip;;</p>

<p>```</p>

<ul>
<li>Dpkg 方式</li>
</ul>


<p>```sh</p>

<h1>普通安装</h1>

<p>dpkg -i package_name.deb</p>

<p>```</p>

<ul>
<li>源码安装（.tar、tar.gz、tar.bz2、tar.Z）</li>
</ul>


<p>```sh</p>

<h1>首先解压源码压缩包，通过 tar 命令来完成</h1>

<p>tar zxf xx.tar.gz
tar zxf xx.tar.Z
tar zxf xx.tgz
bunzip2 xx.bz2
tar xf xx.tar</p>

<h1>进入到解压出的目录中，查看README之类的说明文件，或使用<code>ls -F --color</code>或<code>ls -F</code>命令查看下可执行文件，可执行文件会以*号的尾部标识。一般依次执行一下操作即可完成安装：</h1>

<p>./configure
make
sudo make install</p>

<p>```</p>

<h3>软件包的卸载</h3>

<ul>
<li>APT 方式</li>
</ul>


<p>```sh</p>

<h1>移除式卸载（移除软件包，当尾部有+时，表示安装）</h1>

<p>apt-get remove softname1 softname2 &hellip;;</p>

<h1>清除式卸载（卸载同时，清除配置）</h1>

<p>apt-get &mdash;purge remove softname1 softname2 &hellip;;</p>

<h1>清除式卸载（卸载同时，清除配置）</h1>

<p>apt-get purge softname1 softname2 &hellip;;</p>

<p>```</p>

<ul>
<li>Dpkg 方式</li>
</ul>


<p>```sh</p>

<h1>移除式卸载</h1>

<p>dpkg -r pkg1 pkg2 &hellip;;</p>

<h1>清除式卸载</h1>

<p>dpkg -P pkg1 pkg2 &hellip;;</p>

<p>```</p>

<h2>查看是否安装某软件包</h2>

<ul>
<li>Dpkg 使用文本文件来作为数据库，通常在<code>/var/lib/dpkg</code>目录下。通常在<code>status</code>文件中存储软件状态和控制信息，在<code>info/</code>目录下备份控制文件，并在其下的<code>.list</code>文件中记录安装文件清单，其下<code>.md5sums</code>保存文件的 MD5 编码。</li>
</ul>


<p>```sh</p>

<p>dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                   Version                  Architecture             Description
+++&ndash;======================================&ndash;========================&ndash;========================&ndash;==================================================================================
ii  account-plugin-aim                     3.8.6-0ubuntu9           amd64                    Messaging account plugin for AIM
ii  account-plugin-facebook                0.11+14.04.20140409.1-0u all                      GNOME Control Center account plugin for single signon &ndash; facebook
ii  account-plugin-flickr                  0.11+14.04.20140409.1-0u all                      GNOME Control Center account plugin for single signon &ndash; flickr
ii  account-plugin-google                  0.11+14.04.20140409.1-0u all                      GNOME Control Center account plugin for single signon
ii  account-plugin-jabber                  3.8.6-0ubuntu9           amd64                    Messaging account plugin for Jabber/XMPP
&hellip;&hellip;</p>

<p>```</p>

<ul>
<li>以上每条记录对应一个软件包，每条记录前三个字符表示软件包的状态标识，后边依次是软件包名称、版本号和简单描述</li>
</ul>


<p>```</p>

<h1>第一个字符为期望值，它包括：</h1>

<pre><code>* u 状态未知，这意味着软件包未安装，并且用户也未发出安装请求
* i 用户请求安装软件包
* r 用户请求卸载软件包
* p 用户请求清除软件包
* h 用户请求保持软件包版本锁定
</code></pre>

<h1>第二个字符为软件包当前状态，包括：</h1>

<pre><code>* n 软件包未安装
* i 软件包安装并完成配置
* c 软件包以前安装过，现在删除了，但是它的配置文件还留在系统中
* u 软件包被解包，但还未配置
* f 试图配置软件包，但是失败了
* h 软件包安装，但是没有安装成功
</code></pre>

<h1>第三个字符为错误状态，包括</h1>

<pre><code>* 空 表示没有问题
* h 软件包被强制保持，因为有其他软件包依赖需求，无法升级
* r 软件包被破坏，可能需要重新安装才能正常使用（包括删除）
* x 软件包被破坏，并且被强制保持
</code></pre>

<p>```</p>

<ul>
<li>其他查询方式</li>
</ul>


<p>```sh</p>

<h1>通配符模糊查询</h1>

<p>dpkg -l nano*</p>

<h1>查询系统中属于 nano 的文件</h1>

<p>dpkg &mdash;listfiles nano</p>

<h1>或</h1>

<p>dpkg-query -L nano</p>

<h1>查看软件nano的详细信息</h1>

<p>dpkg -s nano</p>

<h1>或</h1>

<p>dpkg-query -s nano</p>

<h1>查看系统中软件包状态，支持模糊查询</h1>

<p>dpkg -l</p>

<h1>或</h1>

<p>dpkg-query -l</p>

<h1>查看某个文件的归属包</h1>

<p>dpkg -S nano</p>

<h1>或</h1>

<p>dpkg-query -S nano</p>

<p>```</p>

<h2>其他命令</h2>

<p>```</p>

<p>apt-cache search # package 搜索包
apt-cache show # package 获取包的相关信息，如说明、大小、版本等
apt-get install # package 安装包，下载软件包及其所有的依赖包，同时进行包的安装或升级。如果某个包被设置了 hold，将不会被升级
apt-get &mdash;reinstall install # package &mdash;reinstall 重新安装包
apt-get -f install # package 强制安装，-f 即 &mdash;fix-missing
apt-get remove # package 删除包以及任何依赖这个包的其他包
apt-get remove &mdash;purge # package 删除包，同时删除配置文件等
apt-get autoremove &mdash;purge # package 删除包及其依赖的软件包和配置文件等，只对6.10有效
apt-get update # 更新源
apt-get upgrade # 更新已安装的包为最新可用版本，不会安装新的或移除老的包，如果一个包改变了依赖关系而需要安装一个新的包，那么它将不会被升级，而是标识为 hold。建议同时使用 -u 选项，能看到哪些包将会被升级
apt-get dist-upgrade # 升级系统，和 apt-get upgrade 类似，但是会安装和移除包来满足依赖关系，具有一定危险性
apt-get dselect-upgrade # 使用 dselect 升级
apt-cache depends # package 了解使用依赖
apt-cache rdepends # package 了解某个具体的依赖，查看该包被哪些包依赖
apt-cache showpkg # 显示 package 更多信息以及和其他包的关系
apt-get build-dep # package 安装相关的编译环境
apt-get source # package 下载该包的源码
apt-get clean # 清理下载文件的存档
apt-get autoclean # 只清理过时的包
apt-get check # 检查是否有损坏的依赖
dpkg -S filename # 查找 filename 属于哪个软件包
apt-file search filename # 查找 filename 属于哪个软件包
apt-file list packagename # 列出软件包的内容
apt-file update # 更新 apt-file 的数据库</p>

<p>dpkg &mdash;info packagename # 列出软件包解包后的包名称
dpkg -l ## 列出当前系统中所有的包，可以和参数 less 一起使用在分屏查看（类似于 rpm -qa）
dpkg -l | grep -i packagename # 查看系统中与 packagename 相关联得包
dpkg -s # 查询已经安装的包的详细信息
dpkg -L # 查询系统中已安装的软件包所安装的位置（类似于 rpm -ql）
dpkg -S # 查询系统中某个文件属于哪个软件包（类似于 rpm -qf）
dpkg -I # 查询 deb 包的详细信息，在一个软件包下载到本地之后看看是否需要安装
dpkg -i # 手动安装软件包（这个命令不能解决软件包之前的依赖性问题），如果在安装某一个软件包的时候遇到了软件依赖的问题，可以用 apt-get -f install 在解决依赖性问题
dpkg -r # 卸载软件包，不是完全的卸载，它的配置文件还在
dpkg -P # 全部卸载（但是还是不能解决软件包的依赖性问题）
dpkg -reconfigure # 重新配置
dpkg-reconfigure &mdash;frontend=dialog debconf # 如果安装时选错了，可以改回来
dpkg -c # 列出内容</p>

<p>```</p>

<h2>参考资料</h2>

<ol>
<li><a href="http://www.cnblogs.com/forward/archive/2012/01/10/2318483.html">ubuntu 安装和查看已安装</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[操作系统原理、设计与应用]]></title>
    <link href="http://blog.longgen.me/blog/2014/05/31/cao-zuo-xi-tong-yuan-li-%2C-she-ji-yu-ying-yong/"/>
    <updated>2014-05-31T12:28:16+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/05/31/cao-zuo-xi-tong-yuan-li-,-she-ji-yu-ying-yong</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>第 1 章 操作系统简介</h2>

<h3>1.1 什么是操作系统</h3>

<p><strong>操作系统</strong>是一个或多个程序的集合，其提供了一系列的服务，是应用程序与计算机硬件之间的接口，其在多个进程中分配和管理资源的共享。</p>

<h4>1.1.1 资源管理者</h4>

<h4>1.1.2 服务提供者</h4>

<h4>1.1.3 虚拟机</h4>

<h3>1.2 操作系统的功能</h3>

<h4>1.2.1 进程</h4>

<p>当管理 CPU 资源时，通常根据正在运行的程序来进行管理。在执行时，我们将这些程序称之为<strong>进程（processes）</strong>。为了支持进程，操作系统通常提供如下服务：</p>

<ul>
<li>创建进程</li>
<li>终止进程</li>
<li>改变进程优先级</li>
<li>提供进程间通信</li>
<li>提供进程同步</li>
</ul>


<p>在内部，操作系统负责<strong>调度（scheduling）</strong>和<strong>上下文切换（context switching）</strong>。调度程序是一种机制，通过这种机制，操作系统选择下一个将要运行的进程。一个进程将 CPU 控制权转交给另一个进程的实际操作称为<strong>上下文切换</strong>。</p>

<h4>1.2.2 存储器</h4>

<p>系统的性能更依赖于存储管理子系统的行为。存储管理的核心是对分配和释放内存的请求做出响应。建立典型存储管理服务集基础的功能如下：</p>

<ul>
<li>直接请求额外内存</li>
<li>直接请求内存（当创建新进程时等情况下）</li>
<li>释放内存并返还给操作系统</li>
<li>请求进程间得共享内存区</li>
</ul>


<p>在大多数环境中，我们要满足更多的内存请求，而不止计算机上实际安装的内存。这种过度分配通常称为<strong>虚拟存储器（virtual memory）</strong>。</p>

<h4>1.2.3 I/O 设备</h4>

<p>在管理 I/O 设备中，通常为进程提供各种各样的服务，这些服务通常包括：</p>

<ul>
<li>向进程开放设备或附加设备</li>
<li>从设备中读取数据</li>
<li>往设备写入数据</li>
<li>关闭与释放设备</li>
<li>对合适设备提供独占访问</li>
<li>提供各种各样的特定功能，如复卷磁带和设置串行线路传输速率</li>
</ul>


<h4>1.2.4 文件系统</h4>

<p>我们使用 I/O 设备来支持的另一个功能是<strong>文件系统（file system）</strong>。在大多数情况下，文件系统支持的请求集与 I/O 设备子系统相似：</p>

<ul>
<li>打开文件</li>
<li>读文件</li>
<li>写文件</li>
<li>关闭文件</li>
<li>在文件中搜索随机位置</li>
<li>读取文件元数据（如文件名、大小、所有者、保护码等）</li>
<li>修改已选中的元数据</li>
</ul>


<h4>1.2.5 安全性</h4>

<p>操作系统绝不允许任何进程终止另一个进程。除了后台的强制运行机制之外，应用程序能请求的服务如下：</p>

<ul>
<li>设置安全性策略</li>
<li>查询安全性策略</li>
<li>验证自身的远程系统</li>
<li>侦听远程系统来验证自身</li>
<li>加密/解密消息，特别是经由网络的消息</li>
</ul>


<h4>1.2.6 联网</h4>

<p>在大多数情况下，联网支持是 I/O 子系统的另外一个应用。I/O 设备除了负责数据位在系统的输入输出之外，操作系统还能标准的实现协议栈。将网络协议设计成若干层是很常见的，每层封装其它层。和 I/O 编程一样，有必要让操作系统负责这些协议。从应用程序的角度来看，网络服务应该包括：</p>

<ul>
<li>与远程服务建立连接</li>
<li>从远程客户端侦听连接</li>
<li>往远程系统发送消息</li>
<li>从远程系统接收消息</li>
<li>关闭与远程系统的连接</li>
</ul>


<h4>1.2.7 用户接口</h4>

<p>与只处理硬件和操作系统的其他功能相比，处理用户相关的问题时，事情往往变得更复杂，因此，用户接口是需要研究的一个大主题。</p>

<h3>1.3 操作系统的历史</h3>

<h4>1.3.1 裸机</h4>

<h4>1.3.2 批处理操作系统</h4>

<p>作业可以以某种交互会话的形式进行提交，提交的作业仍作为批的一部分运行，以这种方式操作的操作系统称为<strong>批处理操作系统（batch operating system）</strong>。批处理操作系统突破了一个用户这个限制。尽管在任何时刻，计算机只为一个用户工作，但在使用所有计算设备的过程中有许多用户存在。</p>

<h4>1.3.3 分时操作系统</h4>

<p><strong>分时操作系统（time-sharing operating system）</strong>、<strong>多道程序操作系统（multiprogramming operating system）</strong>或<strong>多任务操作系统（multitasking operating system）</strong>。这类新型操作系统突破了一个程序这个限制。</p>

<h4>1.3.4 分布式操作系统</h4>

<p><strong>分布式操作系统（distributed operating system）</strong>。一些具有多个 CPU 的计算机共享单一物理内存和相同的 I/O 设备，我们将这类计算机称为<strong>对称多处理（symmetric multiprocessing，SMP）系统</strong>。</p>

<h3>1.4 组织操作系统的技术</h3>

<h4>1.4.1 单块设计</h4>

<p>单块（monolithic）设计。一般认为这类设计的特点是缺乏任何其他的组织形式，但在现实中，单块设计恰好是将设计组织为单个程序。与任何程序一样，这样的设计具有良好的组织结构。大多数操作系统是沿着这个思路进行组织的。</p>

<h4>1.4.2 分层设计</h4>

<p>分层设计的基本思想是：每层增加抽象层，它建立再较低层提供的函数之上。Comer 教授开发的 XINU 操作系统是遵循分层设计的很好例子。</p>

<h4>1.4.3 微内核设计</h4>

<p>一些设计师认为应该将许多传统的核心功能从内核移到其他进程中去，而这些进程由内核进行管理。原则上，这将使内核更小、更容易编写和维护。在这种设计中，在单块内核中通过函数调用完成的许多工作都是要使用微内核的消息传递来处理的。微内核设计影响组件间的通信，本可以通过参数传递或共享变量进行的通信都必须由消息进行传递。微内核操作系统设计的另一个挑战是安全性问题。</p>

<p>微内核设计很好的示例包括 Tanenbaum 教授的 MINIX、Hurd（部分的 GNU 环境来自软件基金会）和 Mach 操作系统，在一些其他用途中，Mash 教授作为 Mac OS X 的基础用于 Apple Macintosh。虽然 Inferno 不是围绕微内核构建的，但通过示例，我们会看到它是如何将一些传统功能转移用户进程的。</p>

<h4>1.4.4 虚拟机设计</h4>

<p>虚拟机操作系统的主要功能是提供硬件有许多副本的错觉。这种做法的典型例子是 IBM 的 VM 操作系统。使用户能同时运行多个操作系统的产品：商业产品 VMware，开源项目 Xen 等。另外一种方法是模拟，在软件中模拟一个完整的计算机，并在此模拟机上运行操作系统。例如：用来运行并行操作系统的 QEMU。</p>

<h3>1.5 引导</h3>

<p>系统从硬件到我们拥有运行操作系统的过程称为<strong>引导（bootstrapping）</strong>。虽然现在引导这个术语已经很常用，但许多制造商还使用其他术语来代替引导，例如：<strong>冷启动（cold start）</strong>、<strong>静启动（dead start）</strong>和<strong>初始程序加载（initial program load，IPL）</strong>。</p>

<p>有三种典型的方法解决引导问题：</p>

<ul>
<li></li>
</ul>


<h3>1.6 系统调用</h3>

<h4>1.6.1 系统调用示例</h4>

<h4>1.6.2 系统调用机制</h4>

<h3>1.7 本章小结</h3>

<h3>1.8 练习</h3>

<h2>第 2 章 操作系统示例</h2>

<h3>2.1 兼容分时系统</h3>

<h4>2.1.1 组织结构</h4>

<h4>2.1.2 引导</h4>

<h3>2.2 多路信息和计算服务</h3>

<h4>2.2.1 组织结构</h4>

<h4>2.2.2 系统调用</h4>

<h3>2.3 RT-11</h3>

<h4>2.3.1 组织结构</h4>

<h3>2.4 第 6 版 UNIX</h3>

<h4>2.4.1 组织结构</h4>

<h4>2.4.2 系统调用</h4>

<h3>2.5 虚拟内存系统</h3>

<h4>2.5.1 组织结构</h4>

<h4>2.5.2 引导</h4>

<h4>2.5.3 系统调用</h4>

<h3>2.6 4.3 BSD</h3>

<h4>2.6.1 组织结构</h4>

<h4>2.6.2 系统调用</h4>

<h3>2.7 Windows NT</h3>

<h4>2.7.1 组织结构</h4>

<h3>2.8 TinyOS</h3>

<h4>2.8.1 组织结构</h4>

<h3>2.9 Xen</h3>

<h4>2.9.1 组织结构</h4>

<h3>2.10 本章小结</h3>

<h3>2.11 练习</h3>

<h2>第 3 章 Inferno 的结构与初始化</h2>

<h3>3.1 Inferno 的起源</h3>

<h3>3.2 基本概念</h3>

<h3>3.3 组织结构</h3>

<h4>3.3.1 基本体系结构</h4>

<h4>3.3.2 源代码组织结构</h4>

<h3>3.4 初始化</h3>

<h4>3.4.1 启动 Inferno</h4>

<h4>3.4.2 宿主操作系统的特定初始化</h4>

<h4>3.4.3 与宿主操作系统无关的初始化</h4>

<h4>3.4.4 启动分时</h4>

<h3>3.5 系统调用</h3>

<h3>3.6 本章小结</h3>

<h3>3.7 练习</h3>

<h2>第 4 章 Linux 的结构与初始化</h2>

<h3>4.1 Linux 的起源</h3>

<h3>4.2 组织结构</h3>

<h4>4.2.1 基本体系结构</h4>

<h4>4.2.2 模块</h4>

<h4>4.2.3 源代码组织结构</h4>

<h3>4.3 初始化</h3>

<h4>4.3.1 引导</h4>

<h4>4.3.2 特定处理器初始化</h4>

<h4>4.3.3 与处理器无关的初始化</h4>

<h4>4.3.4 启动分时</h4>

<h4>4.3.5 初始化管理级的初始化</h4>

<h3>4.4 系统调用</h3>

<h4>4.4.1 处理应用方得系统调用</h4>

<h4>4.4.2 处理内核方的系统调用</h4>

<h3>4.5 本章小结</h3>

<h3>4.6 练习</h3>

<h2>第 5 章 进程管理原理</h2>

<h3>5.1 进程的概念</h3>

<h3>5.2 实现进程</h3>

<h4>5.2.1 进程操作</h4>

<h4>5.2.2 进程状态</h4>

<h4>5.2.3 进程表</h4>

<h3>5.3 线程</h3>

<h3>5.4 调度</h3>

<h4>5.4.1 先来先服务</h4>

<h4>5.4.2 最短作业优先</h4>

<h4>5.4.3 轮转法</h4>

<h4>5.4.4 优先级调度</h4>

<h4>5.4.5 调整调度参数</h4>

<h4>5.4.6 两级调度</h4>

<h4>5.4.7 实时调度</h4>

<h4>5.4.8 嵌入式系统的调度</h4>

<h3>5.5 上下文切换</h3>

<h3>5.6 进程的创建与终止</h3>

<h3>5.7 临界区</h3>

<h4>5.7.1 中断控制</h4>

<h4>5.7.2 原子操作指令</h4>

<h4>5.7.3 Peterson 算法</h4>

<h4>5.7.4 信号量</h4>

<h4>5.7.5 管程</h4>

<h4>5.7.6 消息传递</h4>

<h4>5.7.7 示例</h4>

<h3>5.8 死锁</h3>

<h4>5.8.1 充分必要条件</h4>

<h4>5.8.2 处理死锁</h4>

<h3>5.9 本章小结</h3>

<h3>5.10 练习</h3>

<h2>第 6 章 进程管理示例</h2>

<h3>6.1 CTSS</h3>

<h4>6.1.1 进程状态</h4>

<h4>6.1.2 系统调用</h4>

<h4>6.1.3 调度</h4>

<h3>6.2 Multics</h3>

<h4>6.2.1 系统调用</h4>

<h4>6.2.2 进程状态</h4>

<h4>6.2.3 调度</h4>

<h3>6.3 RT-11</h3>

<h4>6.3.1 系统调用</h4>

<h4>6.3.2 进程状态</h4>

<h4>6.3.3 进程表</h4>

<h4>6.3.4 调度</h4>

<h3>6.4 第 6 版 UNIX</h3>

<h4>6.4.1 系统调用</h4>

<h4>6.4.2 进程状态</h4>

<h4>6.4.3 进程表</h4>

<h4>6.4.4 调度</h4>

<h3>6.5 4.3 BSD</h3>

<h4>6.5.1 系统调用</h4>

<h4>6.5.2 进程状态与进程表</h4>

<h4>6.5.3 调度</h4>

<h3>6.6 VMS</h3>

<h4>6.6.1 系统调用</h4>

<h4>6.6.2 进程状态</h4>

<h4>6.6.3 调度</h4>

<h3>6.7 Windows NT</h3>

<h4>6.7.1 系统调用</h4>

<h4>6.7.2 进程状态</h4>

<h4>6.7.3 进程表与线程表</h4>

<h4>6.7.4 调度</h4>

<h3>6.8 TinyOS</h3>

<h3>6.9 Xen</h3>

<h3>6.10 本章小结</h3>

<h3>6.11 练习</h3>

<h2>第 7 章 Inferno 中的进程管理</h2>

<h3>7.1 Inferno 中的进程</h3>

<h3>7.2 进程的状态</h3>

<h4>7.2.1 内核进程</h4>

<h4>7.2.2 用户进程</h4>

<h3>7.3 进程的数据结构</h3>

<h4>7.3.1 内核进程表</h4>

<h4>7.3.2 内核进程表项</h4>

<h4>7.3.3 用户进程表</h4>

<h4>7.3.4 用户进程表项</h4>

<h3>7.4 进程的创建</h3>

<h4>7.4.1 解释进程创建指令</h4>

<h4>7.4.2 实现进程创建</h4>

<h3>7.5 进程的终止</h3>

<h3>7.6 进程调度</h3>

<h4>7.6.1 插入就绪表</h4>

<h4>7.6.2 从就绪表中删除</h4>

<h4>7.6.3 分时</h4>

<h4>7.6.4 运行时间片</h4>

<h3>7.7 本章小结</h3>

<h3>7.8 练习</h3>

<h2>第 8 章 Linux 中的进程管理</h2>

<h3>8.1 进程与线程</h3>

<h4>8.1.1 Linux 中的内核线程</h4>

<h4>8.1.2 进程间的关系</h4>

<h3>8.2 系统调用</h3>

<h3>8.3 进程状态</h3>

<h3>8.4 进程表</h3>

<h3>8.5 进程的创建</h3>

<h4>8.5.1 处理系统调用</h4>

<h4>8.5.2 创建进程</h4>

<h4>8.5.3 特定体系结构的步骤</h4>

<h3>8.6 进程调度</h3>

<h4>8.6.1 优先级</h4>

<h4>8.6.2 队列结构</h4>

<h4>8.6.3 时钟计时单元</h4>

<h4>8.6.4 调度程序</h4>

<h3>8.7 本章小结</h3>

<h3>练习</h3>

<h2>第 9 章 存储管理原理</h2>

<h3>9.1 存储层次结构</h3>

<h3>9.2 地址变换</h3>

<h4>9.2.1 基址/上下界寄存器</h4>

<h4>9.2.2 分段存储</h4>

<h4>9.2.3 分页存储</h4>

<h3>9.3 存储相关的服务</h3>

<h3>9.4 存储布局</h3>

<h3>9.5 内存分配技术</h3>

<h4>9.5.1 空闲空间管理</h4>

<h4>9.5.2 碎片</h4>

<h4>9.5.3 分区</h4>

<h4>9.5.4 选择策略</h4>

<h4>9.5.5 伙伴系统管理</h4>

<h3>9.6 过度分配技术</h3>

<h4>9.6.1 交换</h4>

<h4>9.6.2 段交换</h4>

<h4>9.6.3 分页</h4>

<h4>9.6.4 段页式</h4>

<h4>9.6.5 内存映射文件</h4>

<h4>9.6.6 写时复制</h4>

<h4>9.6.7 性能问题</h4>

<h3>9.7 嵌入式系统的存储管理</h3>

<h3>9.8 本章小结</h3>

<h3>练习</h3>

<h2>第 10 章 存储管理示例</h2>

<h3>10.1 CTSS</h3>

<h3>10.2 Multics</h3>

<h4>10.2.1 存储相关的系统调用</h4>

<h4>10.2.2 存储布局</h4>

<h4>10.2.3 段式管理与页式管理</h4>

<h3>10.3 RT-11</h3>

<h4>10.3.1 存储相关的系统调用</h4>

<h4>10.3.2 存储布局</h4>

<h4>10.3.3 USR 与 KMON 交换</h4>

<h3>10.4 第 6 版 UNIX</h3>

<h4>10.4.1 存储相关的系统调用</h4>

<h4>10.4.2 存储布局</h4>

<h4>10.4.3 空闲空间管理</h4>

<h4>10.4.4 分配</h4>

<h4>10.4.5 交换</h4>

<h3>10.5 4.3 BSD</h3>

<h4>10.5.1 存储相关的系统调用</h4>

<h4>10.5.2 存储布局</h4>

<h4>10.5.3 空闲空间管理</h4>

<h4>10.5.4 交换与页替换</h4>

<h3>10.6 VMS</h3>

<h4>10.6.1 页表</h4>

<h4>10.6.2 存储布局</h4>

<h4>10.6.3 空闲空间管理</h4>

<h4>10.6.4 交换与页替换</h4>

<h4>10.6.5 存储相关的系统调用</h4>

<h3>10.7 Windows NT</h3>

<h4>10.7.1 系统调用</h4>

<h4>10.7.2 存储布局</h4>

<h4>10.7.3 页式管理</h4>

<h3>10.8 TinyOS</h3>

<h3>10.9 Xen</h3>

<h4>10.9.1 超级调用</h4>

<h4>10.9.2 存储布局</h4>

<h4>10.9.3 页式管理</h4>

<h3>10.10 本章小结</h3>

<h3>练习</h3>

<h2>第 11 章 Inferno 中的存储管理</h2>

<h3>11.1 概述</h3>

<h3>11.2 存储布局</h3>

<h3>11.3 存储管理的数据结构</h3>

<h4>11.3.1 存储池</h4>

<h4>11.3.2 存储块</h4>

<h3>11.4 存储管理的实现</h3>

<h4>11.4.1 分配内存</h4>

<h4>11.4.2 从树中删除空闲块</h4>

<h4>11.4.3 释放内存</h4>

<h4>11.4.4 把空闲块插入树中</h4>

<h3>11.5 垃圾收集</h3>

<h4>11.5.1 堆结构</h4>

<h4>11.5.2 引用计数</h4>

<h4>11.5.3 并发垃圾收集器</h4>

<h4>11.5.4 实现并发垃圾收集</h4>

<h3>11.6 本章小结</h3>

<h3>11.7 练习</h3>

<h2>第 12 章 Linux 中的存储管理</h2>

<h3>12.1 存储布局</h3>

<h3>12.2 系统调用</h3>

<h3>12.3 分配机制</h3>

<h4>12.3.1 管理区页的分配</h4>

<h4>12.3.2 slab 分配器</h4>

<h4>12.3.3 内核的内存分配</h4>

<h3>12.4 页管理</h3>

<h4>12.4.1 页表</h4>

<h4>12.4.2 页替换</h4>

<h3>12.5 存储管理的数据结构</h3>

<h4>12.5.1 进程分配的表示</h4>

<h4>12.5.2 虚拟内存区表示</h4>

<h3>12.6 存储管理的实现</h3>

<h4>12.6.1 处理分配系统调用</h4>

<h4>12.6.2 增加区域</h4>

<h4>12.6.3 处理缺页</h4>

<h4>12.6.4 解决缺页错误</h4>

<h4>12.6.5 处理新页面</h4>

<h3>12.7 本章小结</h3>

<h3>12.8 练习</h3>

<h2>第 13 章 I/O 设备管理原理</h2>

<h3>13.1 I/O 子系统的要素</h3>

<h3>13.2 I/O 设备的硬件特性</h3>

<h4>13.2.1 磁盘驱动器</h4>

<h4>13.2.2 串口通信</h4>

<h4>13.2.3 控制器接口技术</h4>

<h3>13.3 I/O 设备类型</h3>

<h4>13.3.1 通信设备与存储设备</h4>

<h4>13.3.2 流设备与块设备</h4>

<h3>13.4 I/O 子系统设计的目标</h3>

<h3>13.5 I/O 设备服务</h3>

<h3>13.6 设备驱动器的结构</h3>

<h3>13.7 设备管理技术</h3>

<h4>13.7.1 缓冲区</h4>

<h4>13.7.2 交叉存取</h4>

<h4>13.7.3 电梯算法</h4>

<h4>13.7.4 RAID</h4>

<h4>13.7.5 水位标志</h4>

<h4>13.7.6 人工输入处理</h4>

<h4>13.7.7 伪设备</h4>

<h3>13.8 本章小结</h3>

<h3>13.9 练习</h3>

<h2>第 14 章 I/O 设备管理示例</h2>

<h3>14.1 CTSS</h3>

<h3>14.2 Multics</h3>

<h3>14.3 RT-11</h3>

<h3>14.4 第 6 版 UNIX</h3>

<h3>14.5 4.3 BSD</h3>

<h3>14.6 VMS</h3>

<h3>14.7 Windows NT</h3>

<h3>14.8 TinyOS</h3>

<h3>14.9 Xen</h3>

<h3>14.10 本章小结</h3>

<h3>14.11 练习</h3>

<h2>第 15 章 Inferno 中的 I/O 设备</h2>

<h3>15.1 设备驱动程序结构</h3>

<h3>15.2 并行端口支持</h3>

<h4>15.2.1 为写请求服务</h4>

<h4>15.2.2 写入单字节</h4>

<h3>15.3 键盘支持</h3>

<h4>15.3.1 初始化键盘控制器</h4>

<h4>15.3.2 处理键盘中断</h4>

<h3>15.4 IDE 磁盘支持</h3>

<h4>15.4.1 处理 I/O 请求</h4>

<h4>15.4.2 初始化 IDE 控制器操作</h4>

<h4>15.4.3 处理 IDE 控制器中断</h4>

<h3>15.5 本章小结</h3>

<h3>15.6 练习</h3>

<h2>第 16 章 Linux 中的 I/O 设备</h2>

<h3>16.1 块请求支持</h3>

<h3>16.2 两半中断处理程序结构</h3>

<h3>16.3 并行端口驱动程序</h3>

<h4>16.3.1 处理系统调用</h4>

<h4>16.3.2 选择合适的底层写入</h4>

<h4>16.3.3 从缓冲区写入字节</h4>

<h4>16.3.4 配置控制器</h4>

<h3>16.4 软盘驱动程序</h3>

<h4>16.4.1 处理请求</h4>

<h4>16.4.2 调度软盘操作</h4>

<h4>16.4.3 执行软盘操作</h4>

<h4>16.4.4 启动命令</h4>

<h4>16.4.5 准备数据传输</h4>

<h4>16.4.6 控制器编程</h4>

<h4>16.4.7 处理软盘中断</h4>

<h4>16.4.8 完成软盘操作</h4>

<h3>本章小结</h3>

<h3>练习</h3>

<h2>第 17 章 文件系统原理</h2>

<h3>17.1 文件系统服务</h3>

<h4>17.1.1 共享与独占访问</h4>

<h4>17.1.2 访问模式</h4>

<h4>17.1.3 文件结构</h4>

<h4>17.1.4 元数据</h4>

<h4>17.1.5 内存映射文件</h4>

<h3>17.2 总体文件系统设计</h3>

<h4>17.2.1 文件系统形式</h4>

<h4>17.2.2 主要数据结构</h4>

<h3>17.3 名称空间</h3>

<h4>17.3.1 驱动器指示符</h4>

<h4>17.3.2 账户说明符</h4>

<h4>17.3.3 分层命名</h4>

<h4>17.3.4 文件扩展名</h4>

<h4>17.3.5 文件版本</h4>

<h4>17.3.6 特殊文件与目录</h4>

<h4>17.3.7 相对路径名与绝对路径名</h4>

<h3>17.4 管理存储空间</h3>

<h4>17.4.1 文件系统元数据</h4>

<h4>17.4.2 数据单位</h4>

<h4>17.4.3 空闲空间管理</h4>

<h4>17.4.4 普通文件</h4>

<h4>17.4.5 稀疏文件</h4>

<h4>17.4.6 分支</h4>

<h4>17.4.7 目录</h4>

<h4>17.4.8 别名</h4>

<h3>17.5 一致性检测</h3>

<h3>17.6 日志与日志结构的文件系统</h3>

<h3>17.7 块高速缓存</h3>

<h3>17.8 本章小结</h3>

<h3>17.9 练习</h3>

<h2>第 18 章 文件系统示例</h2>

<h3>18.1 CTSS</h3>

<h4>18.1.1 第一个 CTSS 文件系统</h4>

<h4>18.1.2 第二个 CTSS 文件系统</h4>

<h3>18.2 Multics</h3>

<h3>18.3 RT-11</h3>

<h3>18.4 第 6 版 UNIX</h3>

<h3>18.5 4.3 BSD</h3>

<h3>18.6 VMS</h3>

<h3>18.7 Windows NT</h3>

<h3>18.8 本章小结</h3>

<h3>18.9 练习</h3>

<h2>第 19 章 Inferno 中的文件系统</h2>

<h3>19.1 文件服务器的作用</h3>

<h3>19.1.1 Styx 协议</h3>

<h3>19.1.2 内置内核文件系统</h3>

<h3>19.1.3 用户空间文件服务器</h3>

<h3>19.2 根设备服务器</h3>

<h4>19.2.1 提供命名服务</h4>

<h4>19.2.2 遍历根服务器树</h4>

<h4>19.2.3 从根服务器读取</h4>

<h3>19.3 通用 Styx 消息处理程序</h3>

<h4>19.3.1 创建目录项</h4>

<h4>19.3.2 生成命名</h4>

<h4>19.3.3 遍历目录树</h4>

<h3>19.4 本地 Inferno 文件系统</h3>

<h4>19.4.1 初始化</h4>

<h4>19.4.2 主服务进程</h4>

<h4>19.4.3 处理 Styx 请求</h4>

<h4>19.4.4 遍历目录树</h4>

<h4>19.4.5 搜索目录</h4>

<h4>19.4.6 读文件</h4>

<h4>19.4.7 磁盘上的数据结构</h4>

<h4>19.4.8 读取目录项</h4>

<h4>19.4.9 读取文件块</h4>

<h4>19.4.10 查找文件块</h4>

<h4>19.4.11 处理间接块</h4>

<h4>19.4.12 从缓冲区高速缓存中获取</h4>

<h3>19.5 本章小结</h3>

<h3>19.6 练习</h3>

<h2>第 20 章 Linux 中的文件系统</h2>

<h3>20.1 虚拟文件系统</h3>

<h4>20.1.1 超级块</h4>

<h4>20.1.2 i- 节点</h4>

<h4>20.1.3 目录项</h4>

<h4>20.1.4 文件</h4>

<h3>20.2 EXT3 文件系统</h3>

<h3>20.3 EXT3 的磁盘结构</h3>

<h4>20.3.1 EXT3 超级块</h4>

<h4>20.3.2 EXT3-I 节点</h4>

<h4>20.3.3 EXT3 目录项</h4>

<h3>20.4 EXT3 命令查找</h3>

<h4>20.4.1 遍历路径</h4>

<h4>20.4.2 通用目录查找（第一部分）</h4>

<h4>20.4.3 通用目录查找（第二部分）</h4>

<h4>20.4.4 EXT3 目录查找</h4>

<h4>20.4.5 EXT3 目录搜索</h4>

<h4>20.4.6 EXT3 目录块搜索</h4>

<h3>20.5 写入文件</h3>

<h4>20.5.1 Linux 的写入系统调用</h4>

<h4>20.5.2 写入通用文件</h4>

<h4>20.5.3 写入 EXT3 文件</h4>

<h3>20.6 在 EXT3 中定位文件块</h3>

<h4>20.5.1 Linux 的写入系统调用</h4>

<h4>20.5.2 写入通用文件</h4>

<h4>20.5.3 写入 EXT3 文件</h4>

<h3>20.6 在 EXT3 中定位文件块</h3>

<h4>20.6.1 标识间接块</h4>

<h4>20.6.2 读取间接块</h4>

<h3>20.7 本章小结</h3>

<h3>20.8 练习</h3>

<h2>第 21 章 操作系统安全原理</h2>

<h3>21.1 用户认证</h3>

<h4>21.1.1 用户名与密码</h4>

<h4>21.1.2 散列函数加密</h4>

<h4>21.1.3 回调</h4>

<h4>21.1.4 挑战/响应认证</h4>

<h4>21.1.5 一次性密码</h4>

<h4>21.1.6 生物认证</h4>

<h3>21.2 基本资源保护</h3>

<h4>21.2.1 特权用户</h4>

<h4>21.2.2 访问 CPU 特性</h4>

<h4>21.2.3 内存访问</h4>

<h4>21.2.4 简单的代码保护</h4>

<h4>21.2.5 访问控制列表</h4>

<h4>21.2.6 权能</h4>

<h3>21.3 威胁类型</h3>

<h4>21.3.1 中间人攻击</h4>

<h4>21.3.2 特洛伊木马</h4>

<h4>21.3.3 陷阱门</h4>

<h4>21.3.4 逻辑/时间炸弹</h4>

<h4>21.3.5 病毒</h4>

<h4>21.3.6 蠕虫</h4>

<h4>21.3.7 隐蔽通道</h4>

<h4>21.3.8 拒绝服务</h4>

<h3>21.4 橙皮书分级</h3>

<h4>21.4.1 D 组</h4>

<h4>21.4.2 C 组</h4>

<h4>21.4.3 B 组</h4>

<h4>21.4.4 A 组</h4>

<h3>21.5 加密</h3>

<h4>21.5.1 对称加密</h4>

<h4>21.5.2 公钥加密学</h4>

<h3>21.6 Multics 的保护环</h3>

<h3>21.7 Inferno 的安全</h3>

<h3>21.8 Linux 的安全</h3>

<h3>21.9 本章小结</h3>

<h3>21.10 练习</h3>

<h2>第 22 章 分布式系统原理</h2>

<h3>22.1 基本概念</h3>

<h4>22.1.1 资源共享</h4>

<h4>22.1.2 同步操作</h4>

<h4>22.1.3 一致性</h4>

<h4>22.1.4 分布式互斥</h4>

<h4>22.1.5 容错</h4>

<h4>22.1.6 自稳定</h4>

<h3>22.2 处理器共享</h3>

<h4>22.2.1 对称多处理</h4>

<h4>22.2.2 集群</h4>

<h4>22.2.3 网格</h4>

<h3>22.3 分布式时钟</h3>

<h4>22.3.1 逻辑时钟</h4>

<h4>22.3.2 物理时钟</h4>

<h3>22.4 选举算法</h3>

<h4>22.4.1 欺负算法</h4>

<h4>22.4.2 环算法</h4>

<h3>22.5 本章小结</h3>

<h3>22.6 练习</h3>

<h2>附录 A 便于宿主 Inferno</h2>

<h3>A.1 建立配置</h3>

<h3>A.2 编译器与开发工具</h3>

<h3>A.3 PATH 环境变量</h3>

<h3>A.4 其他环境变量</h3>

<h3>A.5 编译系统</h3>

<h3>A.6 运行新版本</h3>

<h3>A.7 小结</h3>

<h2>附录 B 编译本地 Inferno</h2>

<h3>B.1 建立配置</h3>

<h3>B.2 创建工具链</h3>

<h3>B.3 创建引导程序代码</h3>

<h3>B.4 建立内核配置</h3>

<h3>B.5 生成加载程序配置</h3>

<h3>B.6 创建内核镜像</h3>

<h3>B.7 生成软盘镜像</h3>

<h3>B.8 运行新内核</h3>

<h3>B.9 小结</h3>

<blockquote><ul>
<li>书名《操作系统原理、设计与应用》</li>
<li>英文名 Principle of Operating Systems：Design and Applications</li>
<li>书号 ISBN 978-7-302-22318-4</li>
<li>Brian L. Stuart 著，葛秀慧 田浩 刘展威 等译</li>
<li>清华大学出版社</li>
<li>2010 年 6 月第 1 版第 1 次印刷</li>
</ul>
</blockquote>
]]></content>
  </entry>
  
</feed>
