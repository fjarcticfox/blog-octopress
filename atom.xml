<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[逆水行舟]]></title>
  <link href="http://blog.longgen.me/atom.xml" rel="self"/>
  <link href="http://blog.longgen.me/"/>
  <updated>2014-08-14T11:20:04+08:00</updated>
  <id>http://blog.longgen.me/</id>
  <author>
    <name><![CDATA[Longgen]]></name>
    <email><![CDATA[fjarcticfox@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sonar 代码质量管理平台]]></title>
    <link href="http://blog.longgen.me/blog/2014/08/05/sonar-dai-ma-zhi-liang-guan-li-ping-tai/"/>
    <updated>2014-08-05T03:28:52+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/08/05/sonar-dai-ma-zhi-liang-guan-li-ping-tai</id>
    <content type="html"><![CDATA[<p>Sonar (SonarQube)是一个开源平台，用于管理源代码的质量。Sonar 不只是一个质量数据报告工具，更是代码质量管理平台。支持的语言包括：Java、PHP、C#、C、Cobol、PL/SQL、Flex 等。</p>

<!-- more -->


<p>主要特点：</p>

<ul>
<li>代码覆盖：通过单元测试，将会显示哪行代码被选中</li>
<li>改善编码规则</li>
<li>搜寻编码规则：按照名字，插件，激活级别和类别进行查询</li>
<li>项目搜寻：按照项目的名字进行查询</li>
<li>对比数据：比较同一张表中的任何测量的趋势</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Homebrew 命令详解]]></title>
    <link href="http://blog.longgen.me/blog/2014/07/20/homebrew-ming-ling-xiang-jie/"/>
    <updated>2014-07-20T16:31:49+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/07/20/homebrew-ming-ling-xiang-jie</id>
    <content type="html"><![CDATA[<p>Homebrew 是 OS X 上的 package 管理工具，用于添加 OS X 中缺失的 package。</p>

<!-- more -->


<h2>获取 Homebrew</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 打开终端窗口, 执行以下脚本。</span>
</span><span class='line'><span class="nv">$ </span>ruby -e <span class="s2">&quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 脚本会解释它的作用，然后在您的确认下执行安装。高级安装选项请看 [这里][2]（需要10.5）。</span>
</span></code></pre></td></tr></table></div></figure>


<h2>使用命令</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># Homebrew installs [the stuff you need][1] that Apple didn’t.</span>
</span><span class='line'><span class="nv">$ </span>brew install wget
</span></code></pre></td></tr></table></div></figure>


<h2>安装目录</h2>

<p>Homebrew 会将 packages 安装到独立目录，然后 symlinks 其中文件到目录 <code>/usr/local</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span><span class="nb">cd</span> /usr/local
</span><span class='line'><span class="nv">$ </span>find Cellar
</span><span class='line'>Cellar/wget/1.15
</span><span class='line'>Cellar/wget/1.15/bin/wget
</span><span class='line'>Cellar/wget/1.15/share/man/man1/wget.1
</span><span class='line'>
</span><span class='line'><span class="nv">$ </span>ls -l bin
</span><span class='line'>bin/wget -&gt; ../Cellar/wget/1.15/bin/wget
</span></code></pre></td></tr></table></div></figure>


<p>Homebrew 的所有文件均会被安装到预定义目录下，另外，你可以将 Homebrew 的安装目录设置在你喜欢的任何地方。</p>

<h2>创建自己的 Homebrew 上的 packages</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>brew create http://foo.com/bar-1.0.tgz
</span><span class='line'>Created /usr/local/Library/Formula/bar.rb
</span></code></pre></td></tr></table></div></figure>


<h2>维护自己的 packages</h2>

<p>Homebrew 基于 git、ruby，所以依据掌握的知识，你可以便捷的撤回你的修改或者合并上游的更新。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 打开编辑</span>
</span><span class='line'><span class="nv">$ </span>brew edit wget <span class="c"># opens in $EDITOR!</span>
</span></code></pre></td></tr></table></div></figure>


<p>Homebrew 的 formulae 都是简单的 Ruby 脚本。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>require <span class="s2">&quot;formula&quot;</span>
</span><span class='line'>
</span><span class='line'>class Wget &lt; Formula
</span><span class='line'>  homepage <span class="s2">&quot;http://www.gnu.org/software/wget/&quot;</span>
</span><span class='line'>  url <span class="s2">&quot;http://ftp.gnu.org/gnu/wget/wget-1.15.tar.gz&quot;</span>
</span><span class='line'>  sha1 <span class="s2">&quot;f3c925f19dfe5ed386daae4f339175c108c50574&quot;</span>
</span><span class='line'>
</span><span class='line'>  def install
</span><span class='line'>    system <span class="s2">&quot;./configure&quot;</span>, <span class="s2">&quot;--prefix=#{prefix}&quot;</span>
</span><span class='line'>    system <span class="s2">&quot;make&quot;</span>, <span class="s2">&quot;install&quot;</span>
</span><span class='line'>  end
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>


<p>Homebrew 使 OS X 更完美。使用 gem 来安装 gems、用 brew 来搞定那些依赖包。</p>

<h2>参考资料</h2>

<ol>
<li><a href="http://brew.sh/index.html">Homebrew &mdash; The missing package manager for OS X</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Npm 命令详解]]></title>
    <link href="http://blog.longgen.me/blog/2014/07/20/npm-ming-ling-xiang-jie/"/>
    <updated>2014-07-20T15:57:15+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/07/20/npm-ming-ling-xiang-jie</id>
    <content type="html"><![CDATA[<p>NPM（Node Packaged Modules），是一个用于管理基于 node.js 编写的 package 的命令行工具。类似于 gem 与 ruby 的关系。</p>

<!-- more -->


<h2>npm 获取配置信息的 6 种方式，优先级由高到低。</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 命令行参数，将 proxy</span>
</span></code></pre></td></tr></table></div></figure>


<h2>npm 常用命令</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 查看用户本身配置文件路径</span>
</span><span class='line'>npm config get userconfig   <span class="c"># defaults to ~/.npmrc</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 查看全局用户配置文件路径</span>
</span><span class='line'>npm config get globalconfig <span class="c"># defaults to /usr/local/etc/npmrc</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 内置配置文件，在 npm 安装目录下的 npmrc 文件夹中</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 设置 npm 配置</span>
</span><span class='line'>npm config <span class="nb">set</span> &lt;key&gt; &lt;value&gt; <span class="o">[</span>--global<span class="o">]</span>
</span><span class='line'>npm config get &lt;key&gt;
</span><span class='line'>npm config delete &lt;key&gt;
</span><span class='line'>npm config list
</span><span class='line'>npm config edit
</span><span class='line'>npm get &lt;key&gt;
</span><span class='line'>npm <span class="nb">set</span> &lt;key&gt; &lt;value&gt; <span class="o">[</span>--global<span class="o">]</span>
</span><span class='line'><span class="c"># 在设置配置属性时属性值默认是被存储于用户配置文件中，如果加上 --global，则被存储在全局配置文件中。</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 查看 npm 的所有配置属性（包括默认配置）</span>
</span><span class='line'>npm config ls -l
</span><span class='line'>
</span><span class='line'><span class="c"># 查看 npm 的各种配置的含义</span>
</span><span class='line'>npm <span class="nb">help </span>config
</span><span class='line'>
</span><span class='line'><span class="c"># 为 npm 设置代理</span>
</span><span class='line'>npm config <span class="nb">set </span>proxy http://server:port
</span><span class='line'>npm config <span class="nb">set </span>https-proxy http://server:port
</span><span class='line'><span class="c"># 如果代理需要认证的话可以这样来设置</span>
</span><span class='line'>npm config <span class="nb">set </span>proxy http://username:password@server:port
</span><span class='line'>npm config <span class="nb">set </span>https-proxy http://username:pawword@server:port
</span><span class='line'><span class="c"># 如果代理不支持 https 的话需要修改 npm 存放 package 的网站地址</span>
</span><span class='line'>npm config <span class="nb">set </span>registry <span class="s2">&quot;http://registry.npmjs.org/&quot;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c"># 卸载</span>
</span><span class='line'>sudo npm uninstall npm -g
</span><span class='line'><span class="c"># 或者，如果上面的命令失败了</span>
</span><span class='line'>sudo make uninstall
</span></code></pre></td></tr></table></div></figure>


<h2>注意事项</h2>

<p>~/.npm 为 cache 目录，用于避免重复下载相同的 package。若不需要，可以执行以下命令清空</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>npm cache clean
</span></code></pre></td></tr></table></div></figure>


<h2>参考资料</h2>

<ol>
<li><a href="https://github.com/npm/npm">npm &mdash; node package manager</a></li>
<li><a href="https://www.npmjs.org/doc/">npm-index</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gradle 安装配置及使用]]></title>
    <link href="http://blog.longgen.me/blog/2014/07/17/gradle-an-zhuang-pei-zhi-ji-shi-yong/"/>
    <updated>2014-07-17T14:37:42+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/07/17/gradle-an-zhuang-pei-zhi-ji-shi-yong</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>简介</h2>

<p>Gradle 版本：2.0，支持新特性如下：</p>

<ul>
<li>更新至 Groovy 2.3.2</li>
<li>支持 Java 8</li>
<li>解决 source 和 javadoc artifacts 的新 API</li>
<li>可以通过 component metadata rules 使用 Ivy extra info</li>
<li>可以通过 plugins.withId() 来整合插件</li>
<li>支持 Ivy 以及 Maven repositories 使用 SFTP scheme</li>
<li>Apache Maven POM profile 现在可以基于系统本身属性信息使用</li>
<li>良好的细粒度控制 native 工具的参数传递</li>
<li>简化了跨平台编译及个性化设置（GCC based toolchains）</li>
<li>为 Ivy repositories 提供新的 &lsquo;ivy&rsquo; layout 支持</li>
<li>代码质量工具的默认版本更新，以便与当前版本 Gradle 相匹配

<blockquote><ul>
<li>Checkstyle：5.7</li>
<li>CodeNarc：0.21</li>
<li>PMD：5.1.1(note that some rulesets were renamed in PMD 5, e.g. basic &ndash;> java-basic)</li>
<li>Findbugs：2.0.3</li>
<li>JaCoCo：0.7.1.201405082137</li>
</ul>
</blockquote></li>
<li>Tooling API 改善</li>
</ul>


<p>更详细的信息，请参考 <a href="http://www.gradle.org/docs/">http://www.gradle.org/docs/</a> 对应版本的 Release Notes。</p>

<h2>与 Eclipse Luna 整合</h2>

<p>eclipse 版本：4.4.0（Luna）</p>

<h2>环境配置</h2>

<ul>
<li>GRADLE_HOME：Gradle 安装目录</li>
<li>path：加入 Gradle bin 目录</li>
<li>GRADLE_OPTS：Gradle 参数选项</li>
<li>JAVA_OPTS：Java 参数选项</li>
</ul>


<h2>eclipse 插件安装</h2>

<h2>参考资料</h2>

<ol>
<li><a href="http://www.gradle.org/">Gradle 主页</a></li>
<li><a href="http://www.gradle.org/downloads">Gradle 下载页</a></li>
<li><a href="http://www.eclipse.org/downloads/">Eclipse 下载页</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Icon Fonts 详解]]></title>
    <link href="http://blog.longgen.me/blog/2014/07/14/icon-fonts-xiang-jie/"/>
    <updated>2014-07-14T21:48:08+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/07/14/icon-fonts-xiang-jie</id>
    <content type="html"><![CDATA[<p>像素完美（Pixel Perfection）、分辨率无关（Resolution Independent）和多平台体验一致性是设计师们的追求。 可访问性（Accessability）、加载性能和重构灵活性是前端工程师们关心的主题。</p>

<!-- more -->


<p>当下互联网设备越来越多，显示分辨率各种各样，为 Web 创建者们带来越来越多的难题。</p>

<p>1）需要为高PPI（aka Retina）显示设备准备@1.5x、@2x、@3x的图片素材。</p>

<p>2）需要针对不同显示屏分辨率来调整优化排版。</p>

<p>3）需要考虑多个分辨率版本的图片的加载性能问题。</p>

<p>4）设备版本碎片化（Version Segmentation）带来的语义和可访问性的问题。</p>

<p>……</p>

<h2>响应式设计</h2>

<p>响应式设计（Responsive Design）作为解决以上问题的方案，已经发展了很多年。其核心是：针对不同的设备和应用场景，做出合理性的适应。狭义地看，就是 Web page 在不同分辨率下借助 media qurey 来调整页面布局和内容显示，三个关键词是：Fluid grids，Flexible images，Media queries。</p>

<p>其中 Flexible images 是最为棘手的地方。因为前面提到，现在的设备多样化，不同分辨率和不同 PPI 给图片自适应带来了空前复杂度。目前还没有一套完美的解决方案来应对，W3C 那边还在拟定 <a href="http://www.w3.org/community/respimg/">Responsive Images</a> 和 <a href="http://www.w3.org/TR/2013/WD-html-picture-element-20130226/">Picture Element</a> 的相关标准。但在这之前你需要采取多管齐下的方式，针对媒体元素不同的使用场景，制定不同的自适应策略。目前主要有三种主流方式：</p>

<p>1）max-width: 100% 来自适应容器：同一张图片，在不同容器里，自动适应到容器的大小。存在的问题是，大尺寸图片在小尺寸屏幕下的带宽浪费和加载速度慢。</p>

<p>2）多版本图片更换：针对写在 CSS 里的 background-image，可以借助 media query 来适应显示 @1x 或 @2x 的版本。针对 HTML 里的图片可以利用 Piturefill.js 来做自适应。</p>

<p>3）使用矢量化图形，包括：icon fonts，SVG。</p>

<h2>什么是 icon fonts</h2>

<p>利用字体工具把我们平时 Web 上用的图形图标（icons）转换成 web fonts，就成了 icon fonts，它可以借助 CSS 的 @font-face 嵌入到网页里，用以显示 icons。因为字体是矢量化图形，它天生具有<code>分辨率无关</code>的特性，在任何分辨率和 PPI 下面，都可以做到完美缩放，不会像传统位图，如：png，jpeg，放大后有锯齿或模糊现象。</p>

<h2>为什么要用 icon fonts</h2>

<ul>
<li>icon fonts 优点</li>
</ul>


<p>1）分辨率无关。</p>

<p>2）文件小：相比图片几十几百KB的容量，icon fonts 几乎是羽翼级轻量。</p>

<p>3）加载性能好：因为图标都被打包进一套字体内，http request 减少。这如同我们常用的 css sprites 技术。</p>

<p>4）支持 CSS 样式：和普通字体一样，你可以利用 CSS 来定义大小、颜色、阴影、hover 状态、透明度、渐变等等。</p>

<p>5）兼容性好：web fonts 起源很早，别说主流浏览器，连 IE6/7 都能良好支持。除了一些老的移动端浏览器，如 Android 2.1 以下的初代浏览器，Opera mini 这类自限型浏览器。</p>

<ul>
<li>icon fonts 缺点</li>
</ul>


<p>1）样式单一，无法针对不同分辨率来调整 icon 的细节，比如降低大尺寸 icon 的线条粗细。</p>

<p>2）颜色单一，CSS 无法方便的去定义彩色的 icon，倒是有通过叠加组合的方式来达到彩色图标的目的。</p>

<p>3）移动端浏览器兼容性还不够完善，像 Opera mini、Windows phone 7.0-7.8 都不能正常显示 icon fonts。</p>

<p>4）有少量的移动设备有可能会和 icon fonts 的字符编码冲突，导致 icon 显示不正常。</p>

<ul>
<li>icon fonts 适用场景</li>
</ul>


<p>1）你的网站是扁平化或简约风格，图标样式单一，颜色为纯色。</p>

<p>2）你的目标用户使用桌面浏览器为主，或者</p>

<p>3）你愿意为非兼容设备做兼容 hack。</p>

<h2>如何制作 icon fonts</h2>

<ul>
<li>利用字体工具手动制作</li>
</ul>


<p>在 icon fonts 自动生成器没有诞生之初，大家只能依靠字体编辑软件来完成 icon fonts 的制作，简单介绍一下手动制作的流程。</p>

<p>1）在 illustrator 或 Sketch 这类矢量图形软件里创建你的 icon。</p>

<p>2）然后把 icon 一个一个导入到字体编辑工具，转换成 glyphs 进行编辑，设置对应的 unicode 编码。常用字体工具有：<a href="http://www.glyphsapp.com/">Glyphs</a>，<a href="http://fontforge.org/">FontForge</a>，<a href="http://www.high-logic.com/font-editor/fontcreator.html">FontCreator</a>。</p>

<p>3）完成glyphs 编辑后，从字体工具导出 OTF 字体文件，然后利用 <a href="http://www.fontsquirrel.com/tools/webfont-generator">Font Squirrel</a> 生成器来生成 web fonts 支持的格式。</p>

<ul>
<li>利用在线工具自动生成</li>
</ul>


<p>利用在线工具生成 icon fonts，比如：阿里巴巴提供的免费在线工具 <a href="http://www.iconfont.cn/">iconfont.cn</a></p>

<p>1）参照 iconfont.cn 提供的图标制作模版，在 Illustrator 画布的 16x16 网格内，参考基线、上升部、下降部来调整图标大小和位置。</p>

<p><img src="http://blog.longgen.me/images/blog/icon_fonts_01.jpg" alt="icon_fonts_01" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>调整矢量图标需要注意：
</span><span class='line'>1. 图形需要闭合，不要用 stroke，否则会显示不出来。
</span><span class='line'>2. 图形合并并扩展。
</span><span class='line'>3. 用单色。
</span><span class='line'>4. 在 16x16 画布中进行排版，这样制作好的 icon fonts 16px 大小的时候和其它字体保持一致。
</span></code></pre></td></tr></table></div></figure>


<p>2）然后从 Illustrator 保存为 SVG 文件，使用默认的 SVG 设置即可。</p>

<p><img src="http://blog.longgen.me/images/blog/icon_fonts_02.jpg" alt="icon_fonts_02" /></p>

<p>3）你可以拖动一个或多个 SVG 图标到 iconfont.cn 的上传表单，完成上传后会提示设置名称和 tag，点击<code>完成上传</code>开始生成 icon fonts。生成完成后，你可以点击要下载的图标加入购物车，然后<code>下载至本地</code>。</p>

<p><img src="http://blog.longgen.me/images/blog/icon_fonts_03.png" alt="icon_fonts_03" /></p>

<p>4）解压刚下载的文件包，除了 EOT、SVG、TTF、WOFF 四种 web fonts 字体外，还有个 demo.html 展示所有 icons 及其对应的字体编码。之所以有 4 种字体格式，是考虑到不同浏览器不同平台对字体格式的支持不一样，具体看下面 CSS 里的注解。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="c">/*复制 4 个字体文件到 assets 或 fonts 目录下，然后在 CSS 文件加入 @font-face 声明(注意更改字体所在的文件路径)。*/</span>
</span><span class='line'>
</span><span class='line'><span class="k">@font-face</span> <span class="p">{</span><span class="nt">font-family</span><span class="o">:</span> <span class="s1">&#39;iconfont&#39;</span><span class="o">;</span>
</span><span class='line'>    <span class="nt">src</span><span class="o">:</span> <span class="nt">url</span><span class="o">(</span><span class="s1">&#39;iconfont.eot&#39;</span><span class="o">);</span> <span class="c">/* IE9*/</span>
</span><span class='line'>    <span class="nt">src</span><span class="o">:</span> <span class="nt">url</span><span class="o">(</span><span class="s1">&#39;iconfont.eot?#iefix&#39;</span><span class="o">)</span> <span class="nt">format</span><span class="o">(</span><span class="s1">&#39;embedded-opentype&#39;</span><span class="o">),</span> <span class="c">/* IE6-IE8 */</span>
</span><span class='line'>    <span class="nt">url</span><span class="o">(</span><span class="s1">&#39;iconfont.woff&#39;</span><span class="o">)</span> <span class="nt">format</span><span class="o">(</span><span class="s1">&#39;woff&#39;</span><span class="o">),</span> <span class="c">/* chrome、firefox */</span>
</span><span class='line'>    <span class="nt">url</span><span class="o">(</span><span class="s1">&#39;iconfont.ttf&#39;</span><span class="o">)</span> <span class="nt">format</span><span class="o">(</span><span class="s1">&#39;truetype&#39;</span><span class="o">),</span> <span class="c">/* chrome、firefox、opera、Safari, Android, iOS 4.2+*/</span>
</span><span class='line'>    <span class="nt">url</span><span class="o">(</span><span class="s1">&#39;iconfont.svg#uxiconfont&#39;</span><span class="o">)</span> <span class="nt">format</span><span class="o">(</span><span class="s1">&#39;svg&#39;</span><span class="o">);</span> <span class="c">/* iOS 4.1- */</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c">/*再定义一个 icon-* 通配我们所有图标的共有 CSS 样式*/</span>
</span><span class='line'>
</span><span class='line'><span class="o">[</span><span class="nt">class</span><span class="o">^=</span><span class="s2">&quot;icon-&quot;</span><span class="o">],</span> <span class="o">[</span><span class="nt">class</span><span class="o">*=</span><span class="s2">&quot; icon-&quot;</span><span class="o">]</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">display</span><span class="o">:</span> <span class="k">inline</span><span class="o">-</span><span class="k">block</span><span class="p">;</span>
</span><span class='line'>  <span class="k">speak</span><span class="o">:</span> <span class="k">none</span>
</span><span class='line'>  <span class="k">font-family</span><span class="o">:</span> <span class="s2">&quot;iconfont&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="k">font-size</span><span class="o">:</span> <span class="m">16px</span><span class="p">;</span>
</span><span class='line'>  <span class="k">line-height</span><span class="o">:</span> <span class="m">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">font-style</span><span class="o">:</span> <span class="k">normal</span><span class="p">;</span>
</span><span class='line'>  <span class="o">-</span><span class="n">webkit</span><span class="o">-</span><span class="k">font</span><span class="o">-</span><span class="n">smoothing</span><span class="o">:</span> <span class="n">antialiased</span><span class="p">;</span>
</span><span class='line'>  <span class="o">-</span><span class="n">moz</span><span class="o">-</span><span class="n">osx</span><span class="o">-</span><span class="k">font</span><span class="o">-</span><span class="n">smoothing</span><span class="o">:</span> <span class="n">grayscale</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c">/*最后是利用 :before 来注入每个 icon 对应的字体编码*/</span>
</span><span class='line'>
</span><span class='line'><span class="nc">.icon-bell</span><span class="nd">:before</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">content</span><span class="o">:</span> <span class="s2">&quot;\003432&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nc">.icon-search</span><span class="nd">:before</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">content</span><span class="o">:</span> <span class="s2">&quot;\003433&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="c">&lt;!--现在你可以这样显示一个铃铛图标--&gt;</span>
</span><span class='line'><span class="nt">&lt;i</span> <span class="na">class=</span><span class="s">&quot;icon-bell&quot;</span><span class="nt">&gt;&lt;/i&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>icon fonts 移动端应用</h2>

<p>icon fonts 在移动端的兼容性稍微差一点：</p>

<p>1）浏览器根本不支持：举例 Opera mini，在移动设备和带宽比较落后的地方，用户量还是很大的，如果你的网站访问数据里这类浏览器流量不可忽视，那么你就需要额外处理 icon fonts 的向下兼容，比如 js 嗅探后用 CSS spirtes 替代。各平台 icon fonts 的兼容情况，参见这张网友测试汇集的<a href="https://docs.google.com/spreadsheet/ccc?key=0Ag5_yGvxpINRdHFYeUJPNnZMWUZKR2ItMEpRTXZPdUE#gid=0">表格</a>。</p>

<p>2）unicode 冲突问题：一般情况下，icon fonts 生成器会使用 PUA（<a href="http://en.wikipedia.org/wiki/Private_Use_Areas">Private Unicode Area</a>）这个安全区域的字符编码（code point）。PUA 是专门预留<code>私用</code>的 unicode 区间, 一般会用 U+E000..U+F8FF 这个 <a href="http://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane">BMP</a> 区间里预留的 PUA code point。比如： 这个 Apple 平台特有的字符，就是用 U+F8FF 这个 code point 来对应的，在其它平台就看不到那个字符。</p>

<p>阿里巴巴的 iconfont.cn 没有遵循这个最佳实践，用得的是 CJK 编码区间（U+3432），所以当你浏览器加载字体出问题时，会还原成一些奇怪的中文文字，这对读屏软件也非常不友好。好在它的管理后台，可以手动的编辑这个 code point。</p>

<p>另外，如果发现有 icon 显示不出来，或被替换成了其它字符，那么更换一下 code point 可能可以快速的解决。</p>

<p>关于如何应用 icon fonts 到原生的 iOS/Android App 中去，iconfont.cn 上面有<a href="http://www.iconfont.cn/help/iconuse.html">具体的教程</a>，可以查看一下。</p>

<h2>其它 icon fonts 工具</h2>

<p>类似 iconfont.cn 这类在线生成工具有很多，就不再一一详细介绍，最著名的还有：<a href="http://icomoon.io/">icomoon</a>，<a href="http://fontello.com/">fontfello</a>。</p>

<p>这些工具基本功能类似，但有少许功能差别，像 icomoon 还支持字体的连字（Ligatures）功能。通过设置 <code>bell</code>为铃铛图标的连字，当你在文本中写 <code>bell</code>时自动转换成铃铛图标。像 fontfello 是开源软件，意味着更加灵活和定制的可能性。</p>

<p>如果你对使用英文软件完全没有障碍，我强烈建议使用 icomoon，体验和功能都非常强大。当然作为国内的同行，还是要支持一下 iconfont.cn。</p>

<p>icon fonts 作为 web fonts 的一种特殊应用，很好的解决了响应式设计中图形无损自适应的难题。设计师不再需要维护不同大小、不同颜色的多版本素材，图形矢量化之后，交给那些在线生成器就可以了。对于前端工程师，利用 HTML+CSS 就可以灵活的使用成百上千种图标，无需担心切图、定位、优化等传统位图要应付的情况。而用户，简洁、清晰的图标带给他们赏心悦目的感觉之外，浏览网站的速度体验也将大大提升。</p>

<h2>参考资料</h2>

<ol>
<li><a href="http://www.infoq.com/cn/articles/icons-fonts-as-your-responsive-strategy">响应式Web图形篇 —— icon fonts 的探析及应用</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NodeJS 安装、配置及使用]]></title>
    <link href="http://blog.longgen.me/blog/2014/07/14/nodejs-an-zhuang-%2C-pei-zhi-ji-shi-yong/"/>
    <updated>2014-07-14T09:40:39+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/07/14/nodejs-an-zhuang-,-pei-zhi-ji-shi-yong</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>Windows 下安装及配置 NodeJS</h2>

<p>直接通过 <a href="http://www.nodejs.org/">NodeJS 主页</a> 中的 INSTALL 按钮下载并安装。当前 NodeJS 最新版本为 v0.10.29。配置环境变量NODEJS_HOME，并加入path。</p>

<ul>
<li>Windows 下安装 PostgreSQL 的 pg Module，可用于 NodeJS 连接 PostgreSQL 数据库</li>
</ul>


<p>1）安装 node-gyp Module</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># nodejs 目录下执行</span>
</span><span class='line'>npm install node-gyp
</span></code></pre></td></tr></table></div></figure>


<p>2）node-gyp（0.13.1）的执行需要依赖 Python 以及 vc++。根据 node-gyp 的 <code>README.md</code> 文件选择合适的 <a href="https://www.python.org/downloads/release/python-273/">Python（v2.7.3）</a>版本安装。。根据操作系统版本及 <code>README.md</code> 说明，选择合适的 <a href="http://go.microsoft.com/?linkid=9816758">vc++ （Win7 下，选择 vc++ 2012）</a>版本安装。</p>

<p>3）安装 pg Module。安装 PostgreSQL 的 Module 之前，请确认 PostgreSQL 的环境变量已经配置好。否则会出现 pg_config 命令无法执行的错误。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># nodejs 目录下执行</span>
</span><span class='line'>npm install pg
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Windows 下安装 PostgreSQL 的 pg.js Module，可用于 NodeJS 连接 PostgreSQL 数据库</li>
</ul>


<p>1）安装 pg.js Module 仅需执行以下操作</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># nodejs 目录下执行</span>
</span><span class='line'>npm install pg.js
</span></code></pre></td></tr></table></div></figure>


<h2>使用</h2>

<h2>参考资料</h2>

<ol>
<li><a href="http://www.nodejs.org/">NodeJS 主页</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【转】RESTful API 设计指南]]></title>
    <link href="http://blog.longgen.me/blog/2014/07/09/%5B%28zhuan-%29%5D-restful-api-she-ji-zhi-nan/"/>
    <updated>2014-07-09T19:30:23+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/07/09/[(zhuan-)]-restful-api-she-ji-zhi-nan</id>
    <content type="html"><![CDATA[<p>网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备……）。
因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致 API 构架的流行，甚至出现<a href="http://www.google.com.hk/search?spm=0.0.0.0.hQSkUs&amp;q=API+first">“API First”</a>的设计思想。<a href="http://en.wikipedia.org/wiki/Representational_state_transfer?spm=0.0.0.0.hQSkUs">RESTful API</a>是目前比较成熟的一套互联网应用程序的 API 设计理论。我以前写过一篇<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html?spm=0.0.0.0.hQSkUs">《理解 RESTful 架构》</a>，探讨如何理解这个概念。</p>

<p>今天，我将介绍 RESTful API 的设计细节，探讨如何设计一套合理、好用的 API。我的主要参考资料是这篇<a href="http://codeplanet.io/principles-good-restful-api-design/?spm=0.0.0.0.hQSkUs">《Principles of good RESTful API Design》</a>。</p>

<!-- more -->


<p><img src="http://blog.longgen.me/images/blog/rest_api_01.jpg" alt="rest_api" /></p>

<h2>协议</h2>

<p>API 与用户的通信协议，总是使用 HTTPs 协议。</p>

<h2>域名</h2>

<p>应该尽量将 API 部署在专用域名之下。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>https://api.example.com
</span></code></pre></td></tr></table></div></figure>


<p>如果确定 API 很简单，不会有进一步扩展，可以考虑放在主域名下。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>https://example.org/api/
</span></code></pre></td></tr></table></div></figure>


<h2>版本（Versioning）</h2>

<p>应该将 API 的版本号放入URL。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>https://api.example.com/v1/
</span></code></pre></td></tr></table></div></figure>


<p>另一种做法是，将版本号放在 HTTP 头信息中，但不如放入 URL 方便和直观。</p>

<h2>路径（Endpoint）</h2>

<p>路径又称”终点”（endpoint），表示API的具体网址。</p>

<p>在 RESTful 架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以 API 中的名词也应该使用复数。
举例来说，有一个 API 提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>https://api.example.com/v1/zoos
</span><span class='line'>https://api.example.com/v1/animals
</span><span class='line'>https://api.example.com/v1/employees
</span></code></pre></td></tr></table></div></figure>


<h2>HTTP 动词</h2>

<p>对于资源的具体操作类型，由 HTTP 动词表示。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 常用的 HTTP 动词有下面五个（括号里是对应的 SQL 命令）。</span>
</span><span class='line'>GET（SELECT）：从服务器取出资源（一项或多项）。
</span><span class='line'>POST（CREATE）：在服务器新建一个资源。
</span><span class='line'>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。
</span><span class='line'>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。
</span><span class='line'>DELETE（DELETE）：从服务器删除资源。
</span><span class='line'>
</span><span class='line'><span class="c"># 还有两个不常用的HTTP动词。</span>
</span><span class='line'>HEAD：获取资源的元数据。
</span><span class='line'>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。
</span><span class='line'>
</span><span class='line'><span class="c"># 下面是一些例子。</span>
</span><span class='line'>GET /zoos：列出所有动物园
</span><span class='line'>POST /zoos：新建一个动物园
</span><span class='line'>GET /zoos/ID：获取某个指定动物园的信息
</span><span class='line'>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）
</span><span class='line'>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）
</span><span class='line'>DELETE /zoos/ID：删除某个动物园
</span><span class='line'>GET /zoos/ID/animals：列出某个指定动物园的所有动物
</span><span class='line'>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物
</span></code></pre></td></tr></table></div></figure>


<h2>过滤信息（Filtering）</h2>

<p>如果记录数量很多，服务器不可能都将它们返回给用户。API 应该提供参数，过滤返回结果。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 下面是一些常见的参数。</span>
</span><span class='line'>?limit<span class="o">=</span>10：指定返回记录的数量
</span><span class='line'>?offset<span class="o">=</span>10：指定返回记录的开始位置。
</span><span class='line'>?sortby<span class="o">=</span>name&amp;order<span class="o">=</span>asc：指定返回结果按照哪个属性排序，以及排序顺序。
</span><span class='line'>?animal_type_id<span class="o">=</span>1：指定筛选条件
</span><span class='line'>
</span><span class='line'><span class="c"># 参数的设计允许存在冗余，即允许 API 路径和 URL 参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</span>
</span></code></pre></td></tr></table></div></figure>


<h2>状态码（Status Codes）</h2>

<p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的 HTTP 动词）。</p>

<ul>
<li>200 OK – [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>
<li>201 CREATED – [POST/PUT/PATCH]：用户新建或修改数据成功。</li>
<li>204 NO CONTENT – [DELETE]：用户删除数据成功。</li>
<li>400 INVALID REQUEST – [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。。</li>
<li>404 NOT FOUND – [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>
<li>500 INTERNAL SERVER ERROR – [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>
</ul>


<p>状态码的完全列表参见<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html?spm=0.0.0.0.hQSkUs">这里</a>。</p>

<h2>错误处理（Error handling）</h2>

<p>如果状态码是 4xx，就应该向用户返回出错信息。一般来说，返回的信息中将 error 作为键名，出错信息作为键值即可。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="err">error:</span> <span class="nt">&quot;Invalid API key&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>返回结果</h2>

<p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>

<ul>
<li>GET /collection：返回资源对象的列表（数组）</li>
<li>GET /collection/resource：返回单个资源对象</li>
<li>POST /collection：返回新生成的资源对象</li>
<li>PUT /collection/resource：返回完整的资源对象</li>
<li>PATCH /collection/resource：返回完整的资源对象</li>
<li>DELETE /collection/resource：返回一个空文档</li>
</ul>


<h2>Hypermedia API</h2>

<p>RESTful API最好做到 Hypermedia，即返回结果中提供链接，连向其他 API 方法，使得用户不查文档，也知道下一步应该做什么。</p>

<p>比如，当用户向 api.example.com 的根目录发出请求，会得到这样一个文档。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span><span class="nt">&quot;link&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>  <span class="nt">&quot;rel&quot;</span><span class="p">:</span>   <span class="s2">&quot;collection https://www.example.com/zoos&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;href&quot;</span><span class="p">:</span>  <span class="s2">&quot;https://api.example.com/zoos&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;List of zoos&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;type&quot;</span><span class="p">:</span>  <span class="s2">&quot;application/vnd.yourformat+json&quot;</span>
</span><span class='line'><span class="p">}}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面代码表示，文档中有一个 link 属性，用户读取这个属性就知道下一步该调用什么 API 了。rel 表示这个 API 与当前网址的关系（collection 关系，并给出该 collection 的网址），href 表示 API 的路径，title 表示 API 的标题，type 表示返回类型。</p>

<p>Hypermedia API 的设计被称为 HATEOAS。Github 的 API 就是这种设计，访问 <a href="https://api.github.com/">https://api.github.com/</a> 会得到一个所有可用 API 的网址列表。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="nt">&quot;current_user_url&quot;</span><span class="p">:</span> <span class="s2">&quot;https://api.github.com/user&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;authorizations_url&quot;</span><span class="p">:</span> <span class="s2">&quot;https://api.github.com/authorizations&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="err">//</span> <span class="err">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从上面可以看到，如果想获取当前用户的信息，应该去访问<a href="https://api.github.com/user">https://api.github.com/user</a>，然后就得到了下面结果。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="nt">&quot;message&quot;</span><span class="p">:</span> <span class="s2">&quot;Requires authentication&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;documentation_url&quot;</span><span class="p">:</span> <span class="s2">&quot;https://developer.github.com/v3&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p>

<h2>其他</h2>

<ul>
<li>API 的身份认证应该使用 OAuth 2.0 框架。</li>
<li>服务器返回的数据格式，应该尽量使用 JSON，避免使用 XML。</li>
</ul>


<h2>参考资料</h2>

<ol>
<li><a href="http://www.google.com.hk/search?spm=0.0.0.0.hQSkUs&amp;q=API+first">RESTful API 设计指南</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PostGIS 安装、配置及使用]]></title>
    <link href="http://blog.longgen.me/blog/2014/07/09/postgis-an-zhuang-%2C-pei-zhi-ji-shi-yong/"/>
    <updated>2014-07-09T10:39:21+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/07/09/postgis-an-zhuang-,-pei-zhi-ji-shi-yong</id>
    <content type="html"><![CDATA[<p>本文主要介绍目前为止最新版本 PostGIS 及 PostgreSQL 的安装、配置及使用。</p>

<!-- more -->


<h2>Windows 下安装及配置</h2>

<p>Windows 下 Postgresql 安装包提供 Application Stack Builder 方式安装插件（包括 PostGIS 插件），所以 Windows 下安装仅需下载 Postgresql 并进行相关操作</p>

<p>Postgresql 下载地址：&lt;></p>

<h2>Linux 下安装及配置</h2>

<h2>从 shape 文件中将数据导入 PostGIS。</h2>

<p>需要注意，shape 文件目录不能包含中文名，shape 文件的编码一般设置为 GBK。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【转】图片服务架构演进]]></title>
    <link href="http://blog.longgen.me/blog/2014/07/07/%5B%28zhuan-%29%5D-tu-pian-fu-wu-jia-gou-yan-jin/"/>
    <updated>2014-07-07T15:55:24+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/07/07/[(zhuan-)]-tu-pian-fu-wu-jia-gou-yan-jin</id>
    <content type="html"><![CDATA[<p>现在几乎任何一个网站、Web App 以及移动 APP 等应用都需要有图片展示的功能，对于图片功能从下至上都是很重要的。必须要具有前瞻性的规划好图片服务器，图片的上传和下载速度至关重要，当然这并不是说一上来就搞很NB的架构，至少具备一定扩展性和稳定性。虽然各种架构设计都有，在这里我只是谈谈我的一些个人想法。</p>

<!-- more -->


<p>对于图片服务器来说IO无疑是消耗资源最为严重的，对于web应用来说需要将图片服务器做一定的分离，否则很可能因为图片服务器的 IO 负载导致应用崩溃。因此尤其对于大型网站和应用来说，非常有必要将图片服务器和应用服务器分离，构建独立的图片服务器集群，构建独立的图片服务器其主要优势：</p>

<ol>
<li>分担 Web 服务器的 I/O 负载-将耗费资源的图片服务分离出来，提高服务器的性能和稳定性。</li>
<li>能够专门对图片服务器进行优化-为图片服务设置有针对性的缓存方案，减少带宽网络成本，提高访问速度。</li>
<li>提高网站的可扩展性-通过增加图片服务器，提高图片服务吞吐能力。</li>
</ol>


<p>从传统互联网的 web1.0，历经 web2.0 时代以及发展到现在的 web3.0，随着图片存储规模的增加，图片服务器的架构也在逐渐发生变化，以下主要论述三个阶段的图片服务器架构演进。</p>

<h2>初始阶段</h2>

<p><img src="http://blog.longgen.me/images/blog/%E6%97%A9%E6%9C%9F%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.png" alt="早期图片服务架构" /></p>

<p>在介绍初始阶段的早期的小型图片服务器架构之前，首先让我们了解一下 NFS 技术，NFS 是 Network File System 的缩写，即网络文件系统。NFS 是由 Sun 开发并发展起来的一项用于在不同机器，不同操作系统之间通过网络互相分享各自的文件。NFS server 也可以看作是一个 FILE SERVER,用于在 UNIX 类系统之间共享文件，可以轻松的挂载(mount)到一个目录上，操作起来就像本地文件一样的方便。</p>

<p>如果不想在每台图片服务器同步所有图片，那么 NFS 是最简单的文件共享方式。NFS 是个分布式的客户机/服务器文件系统，NFS 的实质在于用户间计算机的共享，用户可以联结到共享计算机并象访问本地硬盘一样访问共享计算机上的文件。具体实现思路是：</p>

<ol>
<li>所有前端 web 服务器都通过 nfs 挂载 3 台图片服务器 export 出来的目录，以接收 web 服务器写入的图片。然后[图片1]服务器挂载另外两台图片服务器的 export 目录到本地给 apache 对外提供访问。</li>
<li>用户上传图片：用户通过 Internet 访问页面提交上传请求 post 到 web 服务器，web 服务器处理完图片后由 web 服务器拷贝到对应的 mount 本地目录。</li>
<li>用户访问图片：用户访问图片时，通过[图片1]这台图片服务器来读取相应 mount 目录里边的图片。</li>
</ol>


<p>以上架构存在的问题：</p>

<ol>
<li>性能：现有结构过度依赖 nfs,当图片服务器的 nfs 服务器有问题时，可能影响到前端 web 服务器。NFS 的问题主要是锁的问题. 很容易造成死锁, 只有硬件重启才能解决。尤其当图片达到一定的量级后，nfs 会有严重的性能问题。</li>
<li>高可用：对外提供下载的图片服务器只有一台，容易出现单点故障。</li>
<li>扩展性：图片服务器之间的依赖过多，而且横向扩展余地不够。</li>
<li>存储：web 服务器上传热点不可控，造成现有图片服务器空间占用不均衡。</li>
<li>安全性：nfs 方式对于拥有 web 服务器的密码的人来说，可以随意修改 nfs 里边的内容，安全级别不高。</li>
</ol>


<p>当然图片服务器的图片同步可以不采用 NFS,也可以采用 ftp 或 rsync，采用 ftp 这样的话每个图片服务器就都保存一份图片的副本，也起到了备份的作用。但是缺点是将图片 ftp 到服务器比较耗时，如果使用异步方式去同步图片的话又会有延时，不过一般的小图片文件也还好了。使用 rsync 同步，当数据文件达到一定的量级后，每次 rsync 扫描会耗时很久也会带来一定的延时性。</p>

<h2>发展阶段</h2>

<p><img src="http://blog.longgen.me/images/blog/%E5%8F%91%E5%B1%95%E9%98%B6%E6%AE%B5%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.png" alt="发展阶段图片服务架构" /></p>

<p>当网站达到一定的规模后，对图片服务器的性能和稳定性有一定的要求后，上述 NFS 图片服务架构面临着挑战，严重的依赖 NFS,而且系统存在单点机器容易出现故障，需要对整体架构进行升级。于是出现了上图图片服务器架构，出现了分布式的图片存储。</p>

<p>其实现的具体思路如下：</p>

<ol>
<li>用户上传图片到 web 服务器后，web 服务器处理完图片，然后再由前端 web 服务器把图片 post 到到[图片1]、[图片2]…[图片N]其中的一个，图片服务器接收到 post 过来的图片，然后把图片写入到本地磁盘并返回对应成功状态码。前端web服务器根据返回状态码决定对应操作，如果成功的话，处理生成各尺寸的缩略图、打水印，把图片服务器对应的 ID 和对应图片路径写入 DB 数据库。</li>
<li>上传控制：我们需要调节上传时，只需要修改 web 服务器 post 到的目的图片服务器的 ID，就可以控制上传到哪台图片存储服务器,对应的图片存储服务器只需要安装 nginx 同时提供一个 python 或者 php 服务接收并保存图片，如果不想开启 python 或者 php 服务，也可以编写一个 nginx 扩展模块。</li>
<li>用户访问流程：用户访问页面的时候，根据请求图片的 URL 到对应图片服务器去访问图片。
如： <a href="http://imgN.xxx.com/image1.jpg">http://imgN.xxx.com/image1.jpg</a></li>
</ol>


<p>此阶段的图片服务器架构，增加了负载均衡和分布式图片存储，能够在一定程度上解决并发访问量高和存储量大的问题。负载均衡在有一定财力的情况下可以考虑 F5 硬负载，当然也可以考虑使用开源的 LVS 软负载(同时还可开启缓存功能)。此时将极大提升访问的并发量，可以根据情况随时调配服务器。当然此时也存在一定的瑕疵，那就是可能在多台 Squid 上存在同一张图片，因为访问图片时可能第一次分到 squid1，在 LVS 过期后第二次访问到 squid2 或者别的，当然相对并发问题的解决，此种少量的冗余完全在我们的允许范围之内。在该系统架构中二级缓存可以使用 squid 也可以考虑使用 varnish 或者 traffic server，对于 cache 的开源软件选型要考率以下几点</p>

<p>1）性能：varnish 本身的技术上优势要高于 squid，它采用了“Visual Page Cache”技术，在内存的利用上，Varnish 比 Squid 具有优势，它避免了 Squid 频繁在内存、磁盘中交换文件，性能要比 Squid 高。varnish 是不能 cache 到本地硬盘上的。还有强大的通过 Varnish 管理端口，可以使用正则表达式快速、批量地清除部分缓存。nginx 是用第三方模块 ncache 做的缓冲，其性能基本达到 varnish，但在架构中 nginx 一般作为反向（静态文件现在用 nginx 的很多，并发能支持到2万+）。在静态架构中，如果前端直接面对的是 cdn 活着前端了 4 层负载的话，完全用 nginx 的 cache 就够了。</p>

<p>2）避免文件系统式的缓存，在文件数据量非常大的情况下，文件系统的性能很差，像 squid,nginx的proxy_store,proxy_cache 之类的方式缓存，当缓存的量级上来后，性能将不能满足要求。开源的 traffic server 直接用裸盘缓存，是一个不错的选择，国内大规模应用并公布出来的主要是淘宝，并不是因为它做的差，而是开源时间晚。Traffic Server 在 Yahoo 内部使用了超过 4 年，主要用于 CDN 服务，CDN 用于分发特定的 HTTP 内容，通常是静态的内容如图片、JavaScript、CSS。当然使用 leveldb 之类的做缓存，我估计也能达到很好的效果。</p>

<p>3）稳定性：squid 作为老牌劲旅缓存，其稳定性更可靠一些，从我身边一些使用者反馈来看 varnish 偶尔会出现 crash 的情况。Traffic Server 在雅虎目前使用期间也没有出现已知的数据损坏情况，其稳定性相对也比较可靠，对于未来我其实更期待 Traffic Server 在国内能够拥有更多的用户。</p>

<p>以上图片服务架构设计消除了早期的 NFS 依赖以及单点问题，时能够均衡图片服务器的空间，提高了图片服务器的安全性等问题，但是又带来一个问题是图片服务器的横向扩展冗余问题。只想在普通的硬盘上存储，首先还是要考虑一下物理硬盘的实际处理能力。是 7200 转的还是 15000 转的，实际表现差别就很大。至于文件系统选择 xfs、ext3、ext4 还是 reiserFs，需要做一些性能方面的测试，从官方的一些测试数据来看，reiserFs 更适合存储一些小图片文件。创建文件系统的时候 Inode 问题也要加以考虑，选择合适大小的 inode size，因为 Linux 为每个文件分配一个称为索引节点的号码 inode，可以将 inode 简单理解成一个指针，它永远指向本文件的具体存储位置。一个文件系统允许的 inode 节点数是有限的，如果文件数量太多，即使每个文件都是 0 字节的空文件，系统最终也会因为节点空间耗尽而不能再创建文件，因此需要在空间和速度上做取舍，构造合理的文件目录索引。</p>

<h2>云存储阶段</h2>

<p><img src="http://blog.longgen.me/images/blog/%E4%BA%91%E5%AD%98%E5%82%A8%E9%98%B6%E6%AE%B5%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.png" alt="云存储阶段图片服务架构" /></p>

<p>2011 年李彦宏在百度联盟峰会上就提到过互联网的读图时代已经到来，图片服务早已成为一个互联网应用中占比很大的部分，对图片的处理能力也相应地变成企业和开发者的一项基本技能,图片的下载和上传速度显得更加重要，要想处理好图片，需要面对的三个主要问题是：大流量、高并发、海量存储。</p>

<p>阿里云存储服务(OpenStorageService，简称OSS)，是阿里云对外提供的海量，安全，低成本，高可靠的云存储服务。用户可以通过简单的 REST 接口，在任何时间、任何地点上传和下载数据，也可以使用 WEB 页面对数据进行管理。同时，OSS 提供 Java、Python、PHP SDK，简化用户的编程。基于 OSS，用户可以搭建出各种多媒体分享网站、网盘、个人企业数据备份等基于大规模数据的服务。在以下图片云存储主要以阿里云的云存储 OSS 为切入点介绍，上图为 OSS 云存储的简单架构示意图。</p>

<p>真正意义上的“云存储”，不是存储而是提供云服务，使用云存储服务的主要优势有以下几点：</p>

<ol>
<li>用户无需了解存储设备的类型、接口、存储介质等。</li>
<li>无需关心数据的存储路径。</li>
<li>无需对存储设备进行管理、维护。</li>
<li>无需考虑数据备份和容灾</li>
<li>简单接入云存储，尽情享受存储服务。</li>
</ol>


<p>架构模块组成</p>

<p><img src="http://blog.longgen.me/images/blog/%E4%BA%91%E5%AD%98%E5%82%A8%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9D%97%E7%BB%84%E6%88%90.png" alt="云存储图片服务架构模块组成" /></p>

<p>1）KV Engine：OSS 中的 Object 源信息和数据文件都是存放在 KV Engine 上。在 6.15 的版本，V Engine 将使用 0.8.6 版本，并使用为 OSS 提供的 OSSFileClient。</p>

<p>2）Quota：此模块记录了 Bucket 和用户的对应关系，和以分钟为单位的 Bucket 资源使用情况。Quota 还将提供 HTTP 接口供 Boss 系统查询。</p>

<p>3）安全模块：安全模块主要记录 User 对应的 ID 和 Key，并提供 OSS 访问的用户验证功能。</p>

<h2>OSS 术语名词汇</h2>

<ul>
<li><p>Access Key ID &amp; Access Key Secret （API 密钥）：用户注册 OSS 时，系统会给用户分配一对 Access Key ID &amp; Access Key Secret，称为 ID 对，用于标识用户，为访问 OSS 做签名验证。</p></li>
<li><p>Service：OSS 提供给用户的虚拟存储空间，在这个虚拟空间中，每个用户可拥有一个到多个 Bucket。</p></li>
<li><p>Bucket：Bucket 是 OSS 上的命名空间；Bucket 名在整个 OSS 中具有全局唯一性，且不能修改；存储在 OSS 上的每个 Object 必须都包含在某个 Bucket 中。一个应用，例如图片分享网站，可以对应一个或多个 Bucket。一个用户最多可创建 10 个 Bucket，但每个 Bucket 中存放的 Object 的数量和大小总和没有限制，用户不需要考虑数据的可扩展性。</p></li>
<li><p>Object：在 OSS 中，用户的每个文件都是一个 Object，每个文件需小于 5TB。Object 包含 key、data 和 user meta。其中，key 是 Object 的名字；data 是 Object 的数据；user meta 是用户对该 object 的描述。</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// 其使用方式非常简单,如下为 java sdk：</span>
</span><span class='line'><span class="n">OSSClient</span> <span class="n">ossClient</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OSSClient</span><span class="o">(</span><span class="n">accessKeyId</span><span class="o">,</span><span class="n">accessKeySecret</span><span class="o">);</span>
</span><span class='line'><span class="n">PutObjectResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">ossClient</span><span class="o">.</span><span class="na">putObject</span><span class="o">(</span><span class="n">bucketname</span><span class="o">,</span> <span class="n">bucketKey</span><span class="o">,</span> <span class="n">inStream</span><span class="o">,</span> <span class="k">new</span> <span class="n">ObjectMetadata</span><span class="o">());</span>
</span><span class='line'><span class="c1">// 执行以上代码即可将图片流上传至 OSS 服务器上。</span>
</span><span class='line'><span class="c1">// 图片的访问方式也非常简单其 url 为：http://bucketname.oss.aliyuncs.com/bucketKey</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>分布式文件系统：用分布式存储有几个好处，分布式能自动提供冗余，不需要我们去备份，担心数据安全，在文件数量特别大的情况下，备份是一件很痛苦的事情，rsync 扫一次可能是就是好几个小时，还有一点就是分布式存储动态扩容方便。当然在国内的其他一些文件系统里，<a href="http://code.taobao.org/p/tfs/src/">TFS</a>和 FASTDFS 也有一些用户，但是 TFS 的优势更是针对一些小文件存储，主要是淘宝在用。另外 FASTDFS 在并发高于 300 写入的情况下出现性能问题，稳定性不够友好。OSS 存储使用的是阿里云基于飞天 5k 平台自主研发的高可用，高可靠的分布式文件系统盘古。分布式文件系统盘古和 Google 的 GFS 类似，盘古的架构是 Master-Slave 主从架构，Master 负责元数据管理，Slave 叫做 Chunk Server，负责读写请求。其中 Master 是基于 Paxos 的多 Master 架构，一个 Master 死了之后，另外一个 Master 可以很快接过去，基本能够做到故障恢复在一分钟以内 。文件是按照分片存放，每个会分三个副本，放在不同的机架上，最后提供端到端的数据校验。</p></li>
<li><p>HAPROXY 负载均衡：基于 haproxy 的自动 hash 架构 ,这是一种新的缓存架构，由 nginx 作为最前端，代理到缓存机器。 nginx 后面是缓存组，由 nginx 经过 url hash 后将请求分到缓存机器。这个架构方便纯 squid 缓存升级，可以在 squid 的机器上加装 nginx。 nginx 有缓存的功能，可以将一些访问量特大的链接直接缓存在 nginx 上，就不用经过多一次代理的请求，能够保证图片服务器的高可用、高性能。比如 favicon.ico 和网站的 logo。 负载均衡负责 OSS 所有的请求的负载均衡，后台的 http 服务器故障会自动切换，从而保证了 OSS 的服务不间断。</p></li>
<li><p>CDN：阿里云 CDN 服务是一个遍布全国的分布式缓存系统，能够将网站文件（如图片或 JavaScript 代码文件）缓存到全国多个城市机房中的服务器上，当一个用户访问你的网站时，会就近到靠近 TA 的城市的服务器上获取数据，这样最终用户访问你的服务速度会非常快。
阿里云 CDN 服务在全国部署超过 100 个节点，能提供给用户优良的网络加速效果。当网站业务突然爆发增长时，无需手忙脚乱地扩容网络带宽，使用 CDN 服务即可轻松应对。和 OSS 服务一样，使用 CDN，需要先在 aliyun.com 网站上开通 CDN 服务。开通后，需要在网站上的管理中心创建你的 distribution（即分发频道），每个 distribution 由两个必须的部分组成：distribution ID 和源站地址。
使用阿里云 OSS 和 CDN 可以非常方便的针对每个 bucket 进行内容加速，因为每个 bucket 对应一个独立的二级域名，针对每个文件进行 CDN 删除，简单、经济地解决服务的存储和网络问题，毕竟大多数网站或应用的存储和网络带宽多半是被图片或视频消耗掉的。
从整个业界来看，最近这样的面向个人用户的云存储如国外的 DropBox 和 Box.net 非常受欢迎，国内的云存储目前比较不错的主要有七牛云存储和又拍云存储。</p></li>
<li><p>上传下载分而治之：图片服务器的图片下载比例远远高于上传比例，业务逻辑的处理也区别明显，上传服器对图片重命名，记录入库信息，下载服务器对图片添加水印、修改尺寸之类的动态处理。从高可用的角度，我们能容忍部分图片下载失败，但绝不能有图片上传失败，因为上传失败，意味着数据的丢失。上传与下载分开，能保证不会因下载的压力影响图片的上传，而且还有一点，下载入口和上传入口的负载均衡策略也有所不同。上传需要经过 Quota Server 记录用户和图片的关系等逻辑处理，下载的逻辑处理如果绕过了前端缓存处理，穿透后端业务逻辑处理，需要从 OSS 获取图片路径信息。近期阿里云会推出基于 CDN 就近上传的功能，自动选择离用户最近的 CDN 节点，使得数据的上传下载速度均得到最优化。相较传统 IDC，访问速度提升数倍。</p></li>
<li><p>图片防盗链处理：如果服务不允许防盗链，那么访问量会引起带宽、服务器压力等问题。比较通用的解决方案是在 nginx 或者 squid 反向代理软件上添加 refer ACL 判断，OSS 也提供了基于 refer 的防盗链技术。当然 OSS 也提供了更为高级的 URL 签名防盗链，其其实现思路如下：</p></li>
</ul>


<p>首先，确认自己的 bucket 权限是 private，即这个 bucket 的所有请求必须在签名认证通过后才被认为是合法的。然后根据操作类型、要访问的 bucket、要访问的 object 以及超时时间，动态地生成一个经过签名的 URL。通过这个签名 URL，你授权的用户就可以在该签名 URL 过期时间前执行相应的操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// 签名的Python代码如下：</span>
</span><span class='line'><span class="n">h</span><span class="o">=</span><span class="n">hmac</span><span class="o">.</span><span class="na">new</span><span class="o">(</span><span class="err">“</span><span class="n">OtxrzxIsfpFjA7SwPzILwy8Bw21TLhquhboDYROV</span><span class="err">”</span><span class="o">,</span> <span class="err">“</span><span class="n">GET</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="n">n1141889120</span><span class="err">\</span><span class="n">n</span><span class="o">/</span><span class="n">oss</span><span class="o">-</span><span class="n">example</span><span class="o">/</span><span class="n">oss</span><span class="o">-</span><span class="n">api</span><span class="o">.</span><span class="na">jpg</span><span class="err">”</span><span class="o">,</span><span class="n">sha</span><span class="o">);</span>
</span><span class='line'><span class="n">urllib</span><span class="o">.</span><span class="na">quote_plus</span> <span class="o">(</span><span class="n">base64</span><span class="o">.</span><span class="na">encodestring</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">digest</span><span class="o">()).</span><span class="na">strip</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中 method 可以是 PUT、GET、HEAD、DELETE 中的任意一种；最后一个参数“timeout”是超时的时间，单位是秒。一个通过上面 Python 方法，计算得到的签名 URL 为：
<a href="http://oss-example.oss-cn-hangzhou.aliyuncs.com/oss-api.jpg?OSSAccessKeyId=44CF9590006BF252F707&amp;Expires=1141889120&amp;Signature=vjbyPxybdZaNmGa%2ByT272YEAiv4%3D">http://oss-example.oss-cn-hangzhou.aliyuncs.com/oss-api.jpg?OSSAccessKeyId=44CF9590006BF252F707&amp;Expires=1141889120&amp;Signature=vjbyPxybdZaNmGa%2ByT272YEAiv4%3D</a></p>

<p>通过这种动态计算签名 URL 的方法，可以有效地保护放在 OSS 上的数据，防止被其他人盗链。</p>

<ul>
<li>图片编辑处理 API：对于在线图片的编辑处理，GraphicsMagick（GraphicsMagick(<a href="http://www.graphicsmagick.org/">http://www.graphicsmagick.org/</a>)）对于从事互联网的技术人员应该不会陌生。GraphicsMagick 是从 ImageMagick 5.5.2 分支出来的，但是现在他变得更稳定和优秀，GM 更小更容易安装、GM 更有效率、GM 的手册非常丰富 GraphicsMagick 的命令与 ImageMagick 基本是一样的。</li>
</ul>


<p>GraphicsMagick 提供了包括裁、缩放、合成、打水印、图像转换、填充等非常丰富的接口 API,其中的开发包 SDK 也非常丰富，包括了 JAVA(im4java)、C、C++、Perl、PHP、Tcl、Ruby 等的调用，支持超过 88 中图像格式，包括重要的 DPX、GIF、JPEG、JPEG-2000、PNG、PDF、PNM 和 TIFF，GraphicsMagick 可以再绝大多数的平台上使用，Linux、Mac、Windows 都没有问题。但是独立开发这些图片处理服务，对服务器的 IO 要求相对要高一些，而且目前这些开源的图片处理编辑库，相对来说还不是很稳定，笔者在使用 GraphicsMagick 的时候就遇到了 tomcat 进程 crash 情况，需要手动重启 tomcat 服务。</p>

<p>阿里云目前已经对外开放图片处理 API,包括了大多数常用处理解决方案：缩略图、打水印、文字水印、样式、管道等。开发者可以非常方便的使用如上图片处理方案，希望越来越多的开发者能够基于 OSS 开放出更多优秀的产品。</p>

<h2>参考资料</h2>

<ol>
<li><a href="http://blog.aliyun.com/967">图片服务架构演进</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【转】SSH 原理与运用]]></title>
    <link href="http://blog.longgen.me/blog/2014/07/04/%5B%28zhuan-%29%5D-ssh-yuan-li-yu-yun-yong/"/>
    <updated>2014-07-04T14:16:19+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/07/04/[(zhuan-)]-ssh-yuan-li-yu-yun-yong</id>
    <content type="html"><![CDATA[<p>SSH 是每一台 Linux 电脑的标准配置。随着 Linux 设备从电脑逐渐扩展到手机、外设和家用电器，SSH 的使用范围也越来越广。不仅程序员离不开它，很多普通用户也每天使用。</p>

<p>SSH 具备多种功能，可以用于很多场合。有些事情，没有它就是办不成。本文是我的学习笔记，总结和解释了 SSH 的常见用法，希望对大家有用。</p>

<!-- more -->


<h2>什么是SSH</h2>

<p>简单说，SSH 是一种网络协议，用于计算机之间的加密登录。
如果一个用户从本地计算机，使用 SSH 协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</p>

<p>最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995 年，芬兰学者 Tatu Ylonen 设计了 SSH 协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为 Linux 系统的标准配置。</p>

<p>需要指出的是，SSH 只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是 OpenSSH，它是自由软件，应用非常广泛。</p>

<p>此外，本文只讨论 SSH 在 Linux Shell 中的用法。如果要在 Windows 系统中使用 SSH，会用到另一种软件 PuTTY，这需要另文介绍。</p>

<h2>最基本的用法</h2>

<p>SSH 主要用于远程登录。假定你要以用户名 user，登录远程主机 host，只要一条简单命令就可以了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>ssh user@host
</span></code></pre></td></tr></table></div></figure>


<p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>ssh host
</span></code></pre></td></tr></table></div></figure>


<p>SSH 的默认端口是 22，也就是说，你的登录请求会送进远程主机的 22 端口。使用 p 参数，可以修改这个端口。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>ssh -p 2222 user@host
</span></code></pre></td></tr></table></div></figure>


<p>上面这条命令表示，ssh 直接连接远程主机的 2222 端口。</p>

<h2>中间人攻击</h2>

<p>SSH 之所以能够保证安全，原因在于它采用了公钥加密。整个过程是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>1）远程主机收到用户的登录请求，把自己的公钥发给用户。
</span><span class='line'>2）用户使用这个公钥，将登录密码加密后，发送回来。
</span><span class='line'>3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。
</span></code></pre></td></tr></table></div></figure>


<p>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像 https 协议，SSH 协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。
可以设想，如果攻击者插在用户与远程主机之间（比如在公共的 wifi 区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么 SSH 的安全机制就荡然无存了。这种风险就是著名的“中间人攻击”（ Man-in-the-middle attack）。
SSH 协议是如何应对的呢？</p>

<h2>口令登陆</h2>

<p>如果你是第一次登录对方主机，系统会出现下面的提示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>ssh user@host
</span><span class='line'>The authenticity of host ‘host <span class="o">(</span>12.18.429.21<span class="o">)</span>’ can’t be established.
</span><span class='line'>RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.
</span><span class='line'>Are you sure you want to <span class="k">continue </span>connecting <span class="o">(</span>yes/no<span class="o">)</span>?
</span></code></pre></td></tr></table></div></figure>


<p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？</p>

<p>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。</p>

<p>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 假定经过风险衡量以后，用户决定接受这个远程主机的公钥。</span>
</span><span class='line'>Are you sure you want to <span class="k">continue </span>connecting <span class="o">(</span>yes/no<span class="o">)</span>? yes
</span><span class='line'>
</span><span class='line'><span class="c"># 系统会出现一句提示，表示host主机已经得到认可。</span>
</span><span class='line'>Warning: Permanently added ‘host,12.18.429.21′ <span class="o">(</span>RSA<span class="o">)</span> to the list of known hosts.
</span><span class='line'>
</span><span class='line'><span class="c"># 然后，会要求输入密码。</span>
</span><span class='line'>Password: <span class="o">(</span>enter password<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果密码正确，就可以登录了。</p>

<p>当远程主机的公钥被接受以后，它就会被保存在文件<code>$HOME/.ssh/known_hosts</code>之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>

<p>每个 SSH 用户都有自己的 known_hosts 文件，此外系统也有一个这样的文件，通常是<code>/etc/ssh/ssh_known_hosts</code>，保存一些对所有用户都可信赖的远程主机的公钥。</p>

<h2>公钥登录</h2>

<p>使用密码登录，每次都必须输入密码，非常麻烦。好在 SSH 还提供了公钥登录，可以省去输入密码的步骤。
所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录 shell，不再要求密码。</p>

<p>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>ssh-keygen
</span></code></pre></td></tr></table></div></figure>


<p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。</p>

<p>运行结束以后，在<code>$HOME/.ssh/</code>目录下，会新生成两个文件：<code>id_rsa.pub</code>和<code>id_rsa</code>。前者是你的公钥，后者是你的私钥。</p>

<p>这时再输入下面的命令，将公钥传送到远程主机 host 上面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>ssh-copy-id user@host
</span></code></pre></td></tr></table></div></figure>


<p>好了，从此你再登录，就不需要输入密码了。</p>

<p>如果还是不行，就打开远程主机的<code>/etc/ssh/sshd_config</code>这个文件，检查下面几行前面”#”注释是否取掉。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>RSAAuthentication yes
</span><span class='line'>PubkeyAuthentication yes
</span><span class='line'>AuthorizedKeysFile .ssh/authorized_keys
</span></code></pre></td></tr></table></div></figure>


<p>然后，重启远程主机的 ssh 服务。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>// ubuntu系统
</span><span class='line'>service ssh restart
</span><span class='line'>
</span><span class='line'>// debian系统
</span><span class='line'>/etc/init.d/ssh restart
</span></code></pre></td></tr></table></div></figure>


<h2>authorized_keys 文件</h2>

<p>远程主机将用户的公钥，保存在登录后的用户主目录的<code>$HOME/.ssh/authorized_keys</code>文件中。公钥就是一段字符串，只要把它追加在<code>authorized_keys</code>文件的末尾就行了。
这里不使用上面的 ssh-copy-id 命令，改用下面的命令，解释公钥的保存过程：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>ssh user@host <span class="s1">&#39;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#39;</span> &lt; ~/.ssh/id_rsa.pub
</span></code></pre></td></tr></table></div></figure>


<p>这条命令由多个语句组成，依次分解开来看：（1）”$ ssh user@host”，表示登录远程主机；（2）单引号中的 mkdir .ssh &amp;&amp; cat >> .ssh/authorized_keys，表示登录后在远程 shell 上执行的命令：（3）”$ mkdir -p .ssh”的作用是，如果用户主目录中的 .ssh 目录不存在，就创建一个；（4）’cat >> .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub 的作用是，将本地的公钥文件<code>~/.ssh/id_rsa.pub</code>，重定向追加到远程文件<code>authorized_keys</code>的末尾。写入<code>authorized_keys</code>文件后，公钥登录的设置就完成了。</p>

<h2>远程操作</h2>

<p>SSH 不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>ssh user@host <span class="s1">&#39;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#39;</span> &lt; ~/.ssh/id_rsa.pub
</span><span class='line'>
</span><span class='line'><span class="c"># 单引号中间的部分，表示在远程主机上执行的操作；后面的输入重定向，表示数据通过 SSH 传向远程主机。</span>
</span><span class='line'>这就是说，SSH 可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过 SSH 来完成。
</span><span class='line'>下面看几个例子。
</span><span class='line'>
</span><span class='line'><span class="c"># 将`$HOME/src/`目录下面的所有文件，复制到远程主机的`$HOME/src/`目录。</span>
</span><span class='line'><span class="nv">$ </span><span class="nb">cd</span> <span class="o">&amp;&amp;</span> tar czv src | ssh user@host <span class="s1">&#39;tar xz&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 将远程主机`$HOME/src/`目录下面的所有文件，复制到用户的当前目录。</span>
</span><span class='line'><span class="nv">$ </span>ssh user@host <span class="s1">&#39;tar cz src&#39;</span> | tar xzv
</span><span class='line'>
</span><span class='line'><span class="c"># 查看远程主机是否运行进程 httpd。</span>
</span><span class='line'><span class="nv">$ </span>ssh user@host <span class="s1">&#39;ps ax | grep [h]ttpd&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>绑定本地端口</h2>

<p>既然 SSH 可以传送数据，那么我们可以让那些不加密的网络连接，全部改走 SSH 连接，从而提高安全性。
假定我们要让 8080 端口的数据，都通过 SSH 传向远程主机，命令就这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>ssh -D 8080 user@host
</span></code></pre></td></tr></table></div></figure>


<p>SSH 会建立一个 socket，去监听本地的 8080 端口。一旦有数据传向那个端口，就自动把它转移到 SSH 连接上面，发往远程主机。可以想象，如果 8080 端口原来是一个不加密端口，现在将变成一个加密端口。</p>

<h2>本地端口转发</h2>

<p>有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成点对点的”端口转发”。为了区别后文的”远程端口转发”，我们把这种情况称为”本地端口转发”（Local forwarding）。</p>

<p>假定 host1 是本地主机，host2 是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台 host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过 host3，将 host1 连上 host2。
我们在 host1 执行下面的命令：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>ssh -L 2121:host2:21 host3
</span></code></pre></td></tr></table></div></figure>


<p>命令中的 L 参数一共接受三个值，分别是”本地端口:目标主机:目标主机端口”，它们之间用冒号分隔。这条命令的意思，就是指定 SSH 绑定本地端口 2121，然后指定 host3 将所有的数据，转发到目标主机 host2 的 21 端口（假定 host2 运行 FTP，默认端口为 21）。</p>

<p>这样一来，我们只要连接 host1 的 2121 端口，就等于连上了 host2 的 21 端口。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>ftp localhost:2121
</span></code></pre></td></tr></table></div></figure>


<p>“本地端口转发”使得 host1 和 host3 之间仿佛形成一个数据传输的秘密隧道，因此又被称为”SSH隧道”。</p>

<h2>远程端口转发</h2>

<p>既然”本地端口转发”是指绑定本地端口的转发，那么”远程端口转发”（remote forwarding）当然是指绑定远程端口的转发。</p>

<p>还是接着看上面那个例子，host1 与 host2 之间无法连通，必须借助 host3 转发。但是，特殊情况出现了，host3 是一台内网机器，它可以连接外网的 host1，但是反过来就不行，外网的 host1 连不上内网的 host3。这时，”本地端口转发”就不能用了，怎么办？</p>

<p>解决办法是，既然 host3 可以连 host1，那么就从 host3 上建立与 host1 的 SSH 连接，然后在 host1 上使用这条连接就可以了。</p>

<p>我们在 host3 执行下面的命令：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>ssh -R 2121:host2:21 host1
</span></code></pre></td></tr></table></div></figure>


<p>R 参数也是接受三个值，分别是”远程主机端口:目标主机:目标主机端口”。这条命令的意思，就是让 host1 监听它自己的 2121 端口，然后将所有数据经由 host3，转发到 host2 的 21 端口。由于对于 host3 来说，host1 是远程主机，所以这种情况就被称为”远程端口绑定”。</p>

<p>绑定之后，我们在 host1 就可以连接 host2 了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>ftp localhost:2121
</span></code></pre></td></tr></table></div></figure>


<p>这里必须指出，”远程端口转发”的前提条件是，host1 和 host3 两台主机都有 sshD 和 ssh 客户端。</p>

<h2>SSH 的其他参数</h2>

<p>SSH 还有一些别的参数，也值得介绍。</p>

<p>N 参数，表示只连接远程主机，不打开远程 shell；T 参数，表示不为这个连接分配 TTY。这个两个参数可以放在一起用，代表这个 SSH 连接只用来传数据，不执行远程操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>ssh -NT -D 8080 host
</span></code></pre></td></tr></table></div></figure>


<p>f 参数，表示 SSH 连接成功后，转入后台运行。这样一来，你就可以在不中断 SSH 连接的情况下，在本地 shell 中执行其他操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>ssh -f -D 8080 host
</span></code></pre></td></tr></table></div></figure>


<p>要关闭这个后台连接，就只有用 kill 命令去杀掉进程。</p>

<h2>参考资料</h2>

<ol>
<li><a href="http://blog.aliyun.com/1251?spm=0.0.0.0.owssBR">SSH 原理与运用（一）：远程登录</a></li>
<li><a href="http://blog.aliyun.com/1257?spm=0.0.0.0.owssBR">SSH 原理与运用（二）：远程操作与端口转发</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Javascript 获取 IP 地址方法]]></title>
    <link href="http://blog.longgen.me/blog/2014/07/04/javascript-huo-qu-ip-di-zhi-fang-fa/"/>
    <updated>2014-07-04T00:11:15+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/07/04/javascript-huo-qu-ip-di-zhi-fang-fa</id>
    <content type="html"><![CDATA[<p>Javascript 获取客户端 IP 的方法如下：</p>

<!-- more -->




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'># 一
</span><span class='line'><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;http://pv.sohu.com/cityjson?ie=utf-8&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</span><span class='line'><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/&lt;A class=&quot;</span><span class="na">infotextkey</span><span class="err">&quot;</span> <span class="na">href=</span><span class="s">&quot;http://www.jbxue.com/jb/js/&quot;</span> <span class="na">target=</span><span class="s">_blank</span><span class="nt">&gt;</span><span class="nx">javascript</span><span class="o">&lt;</span><span class="err">/A&gt;&quot;&gt;document.write(returnCitySN[&quot;cip&quot;]+&#39;,&#39;+returnCitySN[&quot;cname&quot;])</span><span class="nt">&lt;/script&gt;</span>
</span><span class='line'>
</span><span class='line'># 二
</span><span class='line'><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;http://pv.sohu.com/cityjson?ie=utf-8&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</span><span class='line'><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/&lt;A class=&quot;</span><span class="na">infotextkey</span><span class="err">&quot;</span> <span class="na">href=</span><span class="s">&quot;http://www.jbxue.com/jb/js/&quot;</span> <span class="na">target=</span><span class="s">_blank</span><span class="nt">&gt;</span><span class="nx">javascript</span><span class="o">&lt;</span><span class="err">/A&gt;&quot;&gt;document.write(returnCitySN[&quot;cip&quot;]+&#39;,&#39;+returnCitySN[&quot;cname&quot;])</span><span class="nt">&lt;/script&gt;</span>
</span><span class='line'>
</span><span class='line'># 三
</span><span class='line'><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span> <span class="na">src=</span><span class="s">&quot;http://fw.qq.com/ipaddress&quot;</span> <span class="na">charset=</span><span class="s">&quot;gb2312&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</span><span class='line'>$(document).ready(function() {$(&quot;#ip&quot;).val(IPData[0]);$(&quot;#add&quot;).val(IPData[2]);})
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【转】Linux Tcpdump 命令详解]]></title>
    <link href="http://blog.longgen.me/blog/2014/07/03/%5B%28zhuan-%29%5D-linux-tcpdump-ming-ling-xiang-jie/"/>
    <updated>2014-07-03T08:33:46+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/07/03/[(zhuan-)]-linux-tcpdump-ming-ling-xiang-jie</id>
    <content type="html"><![CDATA[<h2>简介</h2>

<p>用简单的话来定义 tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump 可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供 and、or、not 等逻辑语句来帮助你去掉无用的信息。</p>

<!-- more -->


<h2>实用命令实例</h2>

<ul>
<li>默认启动</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 普通情况下，直接启动 tcpdump 将监视第一个网络接口上所有流过的数据包。</span>
</span><span class='line'>tcpdump
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>监视指定网络接口的数据包</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 如果不指定网卡，默认 tcpdump 只会监视第一个网络接口，一般是 eth0。</span>
</span><span class='line'>tcpdump -i eth1
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>监视指定主机的数据包</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 打印所有进入或离开 sundown 的数据包.</span>
</span><span class='line'>tcpdump host sundown
</span><span class='line'>
</span><span class='line'><span class="c"># 也可以指定ip,例如截获所有 210.27.48.1 的主机收到的和发出的所有的数据包</span>
</span><span class='line'>tcpdump host 210.27.48.1
</span><span class='line'>
</span><span class='line'><span class="c"># 打印 helios 与 hot 或者与 ace 之间通信的数据包</span>
</span><span class='line'>tcpdump host helios and <span class="se">\(</span> hot or ace <span class="se">\)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 截获主机 210.27.48.1 和主机 210.27.48.2 或 210.27.48.3 的通信</span>
</span><span class='line'>tcpdump host 210.27.48.1 and <span class="se">\(</span>210.27.48.2 or 210.27.48.3 <span class="se">\)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 打印 ace 与任何其他主机之间通信的 IP 数据包, 但不包括与 helios 之间的数据包.</span>
</span><span class='line'>tcpdump ip host ace and not helios
</span><span class='line'>
</span><span class='line'><span class="c"># 如果想要获取主机 210.27.48.1 除了和主机 210.27.48.2 之外所有主机通信的 ip 包，使用命令：</span>
</span><span class='line'>tcpdump ip host 210.27.48.1 and ! 210.27.48.2
</span><span class='line'>
</span><span class='line'><span class="c"># 截获主机 hostname 发送的所有数据</span>
</span><span class='line'>tcpdump -i eth0 src host hostname
</span><span class='line'>
</span><span class='line'><span class="c"># 监视所有送到主机 hostname 的数据包</span>
</span><span class='line'>tcpdump -i eth0 dst host hostname
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>监视指定主机和端口的数据包</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 如果想要获取主机 210.27.48.1 接收或发出的 telnet 包，使用如下命令</span>
</span><span class='line'>tcpdump tcp port 23 host 210.27.48.1
</span><span class='line'>
</span><span class='line'><span class="c"># 对本机的 udp 123 端口进行监视 123 为 ntp 的服务端口</span>
</span><span class='line'>tcpdump udp port 123
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>监视指定网络的数据包</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 打印本地主机与 Berkeley 网络上的主机之间的所有通信数据包 (nt: ucb-ether, 此处可理解为‘Berkeley网络’的网络地址，此表达式最原始的含义可表达为: 打印网络地址为 ucb-ether 的所有数据包)</span>
</span><span class='line'>tcpdump net ucb-ether
</span><span class='line'>
</span><span class='line'><span class="c"># 打印所有通过网关 snup 的 ftp 数据包(注意, 表达式被单引号括起来了, 这可以防止 shell 对其中的括号进行错误解析)</span>
</span><span class='line'>tcpdump <span class="s1">&#39;gateway snup and (port ftp or ftp-data)&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 打印所有源地址或目标地址是本地主机的 IP 数据包</span>
</span><span class='line'><span class="o">(</span>如果本地网络通过网关连到了另一网络, 则另一网络并不能算作本地网络.<span class="o">(</span>nt: 此句翻译曲折,需补充<span class="o">)</span>.localnet 实际使用时要真正替换成本地网络的名字<span class="o">)</span>
</span><span class='line'>tcpdump ip and not net localnet
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>监视指定协议的数据包</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 打印 TCP 会话中的的开始和结束数据包, 并且数据包的源或目的不是本地网络上的主机.(nt: localnet, 实际使用时要真正替换成本地网络的名字))</span>
</span><span class='line'>tcpdump <span class="s1">&#39;tcp[tcpflags] &amp; (tcp-syn|tcp-fin) != 0 and not src and dst net localnet&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 打印所有源或目的端口是 80，网络层协议为 IPv4，并且含有数据，而不是 SYN，FIN 以及 ACK-only 等不含数据的数据包.(ipv6 的版本的表达式可做练习)</span>
</span><span class='line'><span class="c"># (nt: 可理解为, ip[2:2]表示整个 ip 数据包的长度, (ip[0]&amp;0xf)&lt;&lt;2)表示 ip 数据包包头的长度(ip[0]&amp;0xf代表包中的 IHL 域, 而此域的单位为 32bit, 要换算</span>
</span><span class='line'>成字节数需要乘以 4,　即左移 2.　<span class="o">(</span>tcp<span class="o">[</span>12<span class="o">]</span>&amp;0xf0<span class="o">)</span>&gt;&gt;4 表示 tcp 头的长度, 此域的单位也是 32bit,　换算成比特数为 <span class="o">((</span>tcp<span class="o">[</span>12<span class="o">]</span>&amp;0xf0<span class="o">)</span> &gt;&gt; 4<span class="o">)</span>　&lt;&lt;　２，
</span><span class='line'>即 <span class="o">((</span>tcp<span class="o">[</span>12<span class="o">]</span>&amp;0xf0<span class="o">)</span>&gt;&gt;2<span class="o">)</span>.　<span class="o">((</span>ip<span class="o">[</span>2:2<span class="o">]</span> - <span class="o">((</span>ip<span class="o">[</span>0<span class="o">]</span>&amp;0xf<span class="o">)</span><span class="s">&lt;&lt;2)) - ((tcp[12</span><span class="o">]</span>&amp;0xf0<span class="o">)</span>&gt;&gt;2<span class="o">))</span> !<span class="o">=</span> 0　表示: 整个 ip 数据包的长度减去 ip 头的长度，再减去
</span><span class='line'> tcp 头的长度不为 0, 这就意味着, ip 数据包中确实是有数据.对于 ipv6 版本只需考虑 ipv6 头中的<span class="s1">&#39;Payload Length&#39;</span> 与 <span class="s1">&#39;tcp头的长度&#39;</span>的差值, 并且其中表达方式<span class="s1">&#39;ip[]&#39;</span>需换成<span class="s1">&#39;ip6[]&#39;</span>.<span class="o">)</span>
</span><span class='line'>tcpdump <span class="s1">&#39;tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c">#  打印长度超过 576 字节, 并且网关地址是 snup 的 IP 数据包</span>
</span><span class='line'>tcpdump <span class="s1">&#39;gateway snup and ip[2:2] &gt; 576&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 打印所有 IP 层广播或多播的数据包， 但不是物理以太网层的广播或多播数据报</span>
</span><span class='line'>tcpdump <span class="s1">&#39;ether[0] &amp; 1 = 0 and ip[16] &gt;= 224&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 打印除&#39;echo request&#39;或者&#39;echo reply&#39;类型以外的 ICMP 数据包（比如,需要打印所有非 ping 程序产生的数据包时可用到此表达式。（nt: &#39;echo reuqest&#39; 与 &#39;echo reply&#39; 这两种类型的 ICMP 数据包通常由 ping 程序产生））</span>
</span><span class='line'>tcpdump <span class="s1">&#39;icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>tcpdump 与wireshark</li>
</ul>


<p>Wireshark（以前是 ethereal）是 Windows 下非常简单易用的抓包工具。但在 Linux 下很难找到一个好用的图形化抓包工具。
还好有 Tcpdump。我们可以用 Tcpdump + Wireshark 的完美组合实现：在 Linux 里抓包，然后在 Windows 里分析包。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap
</span><span class='line'>
</span><span class='line'><span class="o">(</span>1<span class="o">)</span>tcp: ip icmp arp rarp 和 tcp、udp、icmp 这些选项等都要放到第一个参数的位置，用来过滤数据报的类型
</span><span class='line'><span class="o">(</span>2<span class="o">)</span>-i eth1 : 只抓经过接口 eth1 的包
</span><span class='line'><span class="o">(</span>3<span class="o">)</span>-t : 不显示时间戳
</span><span class='line'><span class="o">(</span>4<span class="o">)</span>-s 0 : 抓取数据包时默认抓取长度为 68 字节。加上 -S 0 后可以抓到完整的数据包
</span><span class='line'><span class="o">(</span>5<span class="o">)</span>-c 100 : 只抓取 100 个数据包
</span><span class='line'><span class="o">(</span>6<span class="o">)</span>dst port ! 22 : 不抓取目标端口是 22 的数据包
</span><span class='line'><span class="o">(</span>7<span class="o">)</span>src net 192.168.1.0/24 : 数据包的源网络地址为 192.168.1.0/24
</span><span class='line'><span class="o">(</span>8<span class="o">)</span>-w ./target.cap : 保存成 cap 文件，方便用 ethereal（即 wireshark）分析
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>使用 tcpdump 抓取 HTTP 包</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 0x4745 为&quot;GET&quot;前两个字母&quot;GE&quot;,0x4854 为&quot;HTTP&quot;前两个字母&quot;HT&quot;。</span>
</span><span class='line'>tcpdump  -XvvennSs 0 -i eth0 tcp<span class="o">[</span>20:2<span class="o">]=</span>0x4745 or tcp<span class="o">[</span>20:2<span class="o">]=</span>0x4854
</span><span class='line'>
</span><span class='line'><span class="c"># tcpdump 对截获的数据并没有进行彻底解码，数据包内的大部分内容是使用十六进制的形式直接打印输出的。显然这不利于分析网络故障，通常的解决办法是先使用带 -w 参数的 tcpdump 截获数据并保存到文件中，然后再使用其他程序(如 Wireshark)进行解码分析。当然也应该定义过滤规则，以避免捕获的数据包填满整个硬盘。</span>
</span></code></pre></td></tr></table></div></figure>


<h2>输出信息含义</h2>

<p>首先我们注意一下，基本上 tcpdump 总的的输出格式为：系统时间 来源主机.端口 > 目标主机.端口 数据包参数</p>

<p>tcpdump 的输出格式与协议有关.以下简要描述了大部分常用的格式及相关例子.</p>

<ul>
<li>链路层头</li>
</ul>


<p>对于FDDI网络, &lsquo;-e&rsquo; 使tcpdump打印出指定数据包的&#8217;frame control&#8217; 域, 源和目的地址, 以及包的长度.(frame control域
控制对包中其他域的解析). 一般的包(比如那些IP datagrams)都是带有&#8217;async&#8217;(异步标志)的数据包，并且有取值0到7的优先级;
比如 &lsquo;async4&#8217;就代表此包为异步数据包，并且优先级别为4. 通常认为,这些包们会内含一个 LLC包(逻辑链路控制包); 这时,如果此包
不是一个ISO datagram或所谓的SNAP包，其LLC头部将会被打印(nt:应该是指此包内含的 LLC包的包头).</p>

<p>对于Token Ring网络(令牌环网络), &lsquo;-e&rsquo; 使tcpdump打印出指定数据包的&#8217;frame control&#8217;和&#8217;access control&#8217;域, 以及源和目的地址,
外加包的长度. 与FDDI网络类似, 此数据包通常内含LLC数据包. 不管 是否有&#8217;-e&#8217;选项.对于此网络上的&#8217;source-routed&#8217;类型数据包(nt:
意译为:源地址被追踪的数据包,具体含义未知,需补充), 其包的源路由信息总会被打印.</p>

<p>对于802.11网络(WLAN,即wireless local area network), &lsquo;-e&rsquo; 使tcpdump打印出指定数据包的&#8217;frame control域,
包头中包含的所有地址, 以及包的长度.与FDDI网络类似, 此数据包通常内含LLC数据包.</p>

<p>(注意: 以下的描述会假设你熟悉SLIP压缩算法 (nt:SLIP为Serial Line Internet Protocol.), 这个算法可以在
RFC-1144中找到相关的蛛丝马迹.)</p>

<p>对于SLIP网络(nt:SLIP links, 可理解为一个网络, 即通过串行线路建立的连接, 而一个简单的连接也可看成一个网络),
数据包的&#8217;direction indicator&#8217;(&lsquo;方向指示标志&rsquo;)(&ldquo;I&#8221;表示入, &#8220;O&#8221;表示出), 类型以及压缩信息将会被打印. 包类型会被首先打印.</p>

<p>类型分为ip, utcp以及ctcp(nt:未知, 需补充). 对于ip包,连接信息将不被打印(nt:SLIP连接上,ip包的连接信息可能无用或没有定义.
reconfirm).对于TCP数据包, 连接标识紧接着类型表示被打印. 如果此包被压缩, 其被编码过的头部将被打印.
此时对于特殊的压缩包,会如下显示:
<em>S+n 或者 </em>SA+n, 其中n代表包的(顺序号或(顺序号和应答号))增加或减少的数目(nt | rt:S,SA拗口, 需再译).
对于非特殊的压缩包,0个或更多的&#8217;改变&#8217;将会被打印.&lsquo;改变&#8217;被打印时格式如下:
&#8216;标志&rsquo;+/&ndash;/=n 包数据的长度 压缩的头部长度.
其中&#8217;标志&#8217;可以取以下值:
U(代表紧急指针), W(指缓冲窗口), A(应答), S(序列号), I(包ID),而增量表达&#8217;=n&#8217;表示被赋予新的值, +/-表示增加或减少.</p>

<p>比如, 以下显示了对一个外发压缩TCP数据包的打印, 这个数据包隐含一个连接标识(connection identifier); 应答号增加了6,
顺序号增加了49, 包ID号增加了6; 包数据长度为3字节(octect), 压缩头部为6字节.(nt:如此看来这应该不是一个特殊的压缩数据包).</p>

<p>ARP/RARP 数据包</p>

<p>tcpdump对Arp/rarp包的输出信息中会包含请求类型及该请求对应的参数. 显示格式简洁明了. 以下是从主机rtsg到主机csam的&#8217;rlogin&#8217;
(远程登录)过程开始阶段的数据包样例:
arp who-has csam tell rtsg
arp reply csam is-at CSAM
第一行表示:rtsg发送了一个arp数据包(nt:向全网段发送,arp数据包）以询问csam的以太网地址
Csam（nt:可从下文看出来, 是Csam）以她自己的以太网地址做了回应(在这个例子中, 以太网地址以大写的名字标识, 而internet
地址(即ip地址)以全部的小写名字标识).</p>

<p>如果使用tcpdump -n, 可以清晰看到以太网以及ip地址而不是名字标识:
arp who-has 128.3.254.6 tell 128.3.254.68
arp reply 128.3.254.6 is-at 02:07:01:00:01:c4</p>

<p>如果我们使用tcpdump -e, 则可以清晰的看到第一个数据包是全网广播的, 而第二个数据包是点对点的:
RTSG Broadcast 0806 64: arp who-has csam tell rtsg
CSAM RTSG 0806 64: arp reply csam is-at CSAM
第一个数据包表明:以arp包的源以太地址是RTSG, 目标地址是全以太网段, type域的值为16进制0806(表示ETHER_ARP(nt:arp包的类型标识)),
包的总长度为64字节.</p>

<ul>
<li>TCP 数据包</li>
</ul>


<p>(注意:以下将会假定你对 RFC-793所描述的TCP熟悉. 如果不熟, 以下描述以及tcpdump程序可能对你帮助不大.(nt:警告可忽略,
只需继续看, 不熟悉的地方可回头再看.).</p>

<p>通常tcpdump对tcp数据包的显示格式如下:
src > dst: flags data-seqno ack window urgent options</p>

<p>src 和 dst 是源和目的IP地址以及相应的端口. flags 标志由S(SYN), F(FIN), P(PUSH, R(RST),
W(ECN CWT(nt | rep:未知, 需补充))或者 E(ECN-Echo(nt | rep:未知,　需补充))组成,
单独一个&#8217;.&lsquo;表示没有flags标识. 数据段顺序号(Data-seqno)描述了此包中数据所对应序列号空间中的一个位置(nt:整个数据被分段,
每段有一个顺序号, 所有的顺序号构成一个序列号空间)(可参考以下例子). Ack 描述的是同一个连接,同一个方向,下一个本端应该接收的
(对方应该发送的)数据片段的顺序号. Window是本端可用的数据接收缓冲区的大小(也是对方发送数据时需根据这个大小来组织数据).
Urg(urgent) 表示数据包中有紧急的数据. options 描述了tcp的一些选项, 这些选项都用尖括号来表示(如 <mss 1024>).</p>

<p>src, dst 和 flags 这三个域总是会被显示. 其他域的显示与否依赖于tcp协议头里的信息.</p>

<p>这是一个从trsg到csam的一个rlogin应用登录的开始阶段.
rtsg.1023 > csam.login: S 768512:768512(0) win 4096 <mss 1024>
csam.login > rtsg.1023: S 947648:947648(0) ack 768513 win 4096 <mss 1024>
rtsg.1023 > csam.login: . ack 1 win 4096
rtsg.1023 > csam.login: P 1:2(1) ack 1 win 4096
csam.login > rtsg.1023: . ack 2 win 4096
rtsg.1023 > csam.login: P 2:21(19) ack 1 win 4096
csam.login > rtsg.1023: P 1:2(1) ack 21 win 4077
csam.login > rtsg.1023: P 2:3(1) ack 21 win 4077 urg 1
csam.login > rtsg.1023: P 3:4(1) ack 21 win 4077 urg 1
第一行表示有一个数据包从rtsg主机的tcp端口1023发送到了csam主机的tcp端口login上(nt:udp协议的端口和tcp协议的端
口是分别的两个空间, 虽然取值范围一致). S表示设置了SYN标志. 包的顺序号是768512, 并且没有包含数据.(表示格式
为:&lsquo;first:last(nbytes)&rsquo;, 其含义是&#8217;此包中数据的顺序号从first开始直到last结束，不包括last. 并且总共包含nbytes的
用户数据&#8217;.) 没有捎带应答(nt:从下文来看，第二行才是有捎带应答的数据包), 可用的接受窗口的大小为4096bytes, 并且请求端(rtsg)
的最大可接受的数据段大小是1024字节(nt:这个信息作为请求发向应答端csam, 以便双方进一步的协商).</p>

<p>Csam 向rtsg 回复了基本相同的SYN数据包, 其区别只是多了一个&#8217; piggy-backed ack&#8217;(nt:捎带回的ack应答, 针对rtsg的SYN数据包).</p>

<p>rtsg 同样针对csam的SYN数据包回复了一ACK数据包作为应答. &lsquo;.&#8217;的含义就是此包中没有标志被设置. 由于此应答包中不含有数据, 所以
包中也没有数据段序列号. 提醒! 此ACK数据包的顺序号只是一个小整数1. 有如下解释:tcpdump对于一个tcp连接上的会话, 只打印会话两端的
初始数据包的序列号,其后相应数据包只打印出与初始包序列号的差异.即初始序列号之后的序列号,　可被看作此会话上当前所传数据片段在整个
要传输的数据中的&#8217;相对字节&#8217;位置(nt:双方的第一个位置都是1, 即&#8217;相对字节&#8217;的开始编号).　&rsquo;-Ｓ&#8217;将覆盖这个功能,　
使数据包的原始顺序号被打印出来.</p>

<p>第六行的含义为:rtsg 向 csam发送了19字节的数据(字节的编号为2到20，传送方向为rtsg到csam). 包中设置了PUSH标志. 在第7行,
csam 喊到， 她已经从rtsg中收到了21以下的字节, 但不包括21编号的字节. 这些字节存放在csam的socket的接收缓冲中, 相应地,
csam的接收缓冲窗口大小会减少19字节(nt:可以从第5行和第7行win属性值的变化看出来). csam在第7行这个包中也向rtsg发送了一个
字节. 在第8行和第9行, csam 继续向rtsg 分别发送了两个只包含一个字节的数据包, 并且这个数据包带PUSH标志.</p>

<p>如果所抓到的tcp包(nt:即这里的snapshot)太小了，以至tcpdump无法完整得到其头部数据, 这时, tcpdump会尽量解析这个不完整的头,
并把剩下不能解析的部分显示为&#8217;[|tcp]&lsquo;. 如果头部含有虚假的属性信息(比如其长度属性其实比头部实际长度长或短), tcpdump会为该头部
显示&rsquo;[bad opt]&lsquo;. 如果头部的长度告诉我们某些选项(nt | rt:从下文来看， 指tcp包的头部中针对ip包的一些选项, 回头再翻)会在此包中,
而真正的IP(数据包的长度又不够容纳这些选项, tcpdump会显示&rsquo;[bad hdr length]&lsquo;.</p>

<p>抓取带有特殊标志的的TCP包(如SYN-ACK标志, URG-ACK标志等).</p>

<p>在TCP的头部中, 有8比特(bit)用作控制位区域, 其取值为:
CWR | ECE | URG | ACK | PSH | RST | SYN | FIN
(nt | rt:从表达方式上可推断:这8个位是用或的方式来组合的, 可回头再翻)</p>

<p>现假设我们想要监控建立一个TCP连接整个过程中所产生的数据包. 可回忆如下:TCP使用3次握手协议来建立一个新的连接; 其与此三次握手
连接顺序对应，并带有相应TCP控制标志的数据包如下:
1) 连接发起方(nt:Caller)发送SYN标志的数据包
2) 接收方(nt:Recipient)用带有SYN和ACK标志的数据包进行回应
3) 发起方收到接收方回应后再发送带有ACK标志的数据包进行回应</p>

<h2>0 15 31</h2>

<h2>| source port | destination port |</h2>

<h2>| sequence number |</h2>

<h2>| acknowledgment number |</h2>

<h2>| HL | rsvd |C|E|U|A|P|R|S|F| window size |</h2>

<h2>| TCP checksum | urgent pointer |</h2>

<p>一个TCP头部,在不包含选项数据的情况下通常占用20个字节(nt | rt:options 理解为选项数据，需回译). 第一行包含0到3编号的字节,
第二行包含编号4-7的字节.</p>

<p>如果编号从0开始算, TCP控制标志位于13字节(nt:第四行左半部分).</p>

<table>
<thead>
<tr>
<th>0 7</th>
<th> 15</th>
<th> 23</th>
<th> 31</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> HL </td>
<td> rsvd </td>
<td>C|E|U|A|P|R|S|F| window size |</td>
</tr>
<tr>
<td>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</td>
<td>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</td>
<td>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</td>
<td>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</td>
</tr>
<tr>
<td></td>
<td> </td>
<td> 13th octet </td>
<td> | |</td>
</tr>
</tbody>
</table>


<p>让我们仔细看看编号13的字节:</p>

<table>
<thead>
<tr>
<th></th>
<th> </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>C|E|U|A|P|R|S|F|</td>
</tr>
<tr>
<td></td>
<td>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;|</td>
</tr>
<tr>
<td></td>
<td>7 5 3 0|</td>
</tr>
</tbody>
</table>


<p>这里有我们感兴趣的控制标志位. 从右往左这些位被依次编号为0到7, 从而 PSH位在3号, 而URG位在5号.</p>

<p>提醒一下自己, 我们只是要得到包含SYN标志的数据包. 让我们看看在一个包的包头中, 如果SYN位被设置, 到底
在13号字节发生了什么:</p>

<table>
<thead>
<tr>
<th></th>
<th>C</th>
<th>E</th>
<th>U</th>
<th>A</th>
<th>P</th>
<th>R</th>
<th>S</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>0 0 0 0 0 0 1 0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>7 6 5 4 3 2 1 0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>


<p>在控制段的数据中, 只有比特1(bit number 1)被置位.</p>

<p>假设编号为13的字节是一个8位的无符号字符型,并且按照网络字节号排序(nt:对于一个字节来说，网络字节序等同于主机字节序), 其二进制值
如下所示:
00000010</p>

<p>并且其10进制值为:</p>

<p>0<em>2<sup>7</sup> + 0</em>2<sup>6</sup> + 0<em>2<sup>5</sup> + 0</em>2<sup>4</sup> + 0<em>2<sup>3</sup> + 0</em>2<sup>2</sup> + 1<em>2<sup>1</sup> + 0</em>2<sup>0</sup> = 2(nt: 1 * 2<sup>6</sup> 表示1乘以2的6次方, 也许这样更
清楚些, 即把原来表达中的指数7 6 &hellip; 0挪到了下面来表达)</p>

<p>接近目标了, 因为我们已经知道, 如果数据包头部中的SYN被置位, 那么头部中的第13个字节的值为2(nt: 按照网络序, 即大头方式, 最重要的字节
在前面(在前面,即该字节实际内存地址比较小, 最重要的字节,指数学表示中数的高位, 如356中的3) ).</p>

<p>表达为tcpdump能理解的关系式就是:
tcp[13] 2</p>

<p>从而我们可以把此关系式当作tcpdump的过滤条件, 目标就是监控只含有SYN标志的数据包:
tcpdump -i xl0 tcp[13] 2 (nt: xl0 指网络接口, 如eth0)</p>

<p>这个表达式是说&#8221;让TCP数据包的第13个字节拥有值2吧&#8221;, 这也是我们想要的结果.</p>

<p>现在, 假设我们需要抓取带SYN标志的数据包, 而忽略它是否包含其他标志.(nt:只要带SYN就是我们想要的). 让我们来看看当一个含有
SYN-ACK的数据包(nt:SYN 和 ACK 标志都有), 来到时发生了什么:
|C|E|U|A|P|R|S|F|
|&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;|
|0 0 0 1 0 0 1 0|
|&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;|
|7 6 5 4 3 2 1 0|</p>

<p>13号字节的1号和4号位被置位, 其二进制的值为:
00010010</p>

<p>转换成十进制就是:</p>

<p>0<em>2<sup>7</sup> + 0</em>2<sup>6</sup> + 0<em>2<sup>5</sup> + 1</em>2<sup>4</sup> + 0<em>2<sup>3</sup> + 0</em>2<sup>2</sup> + 1<em>2<sup>1</sup> + 0</em>2 = 18(nt: 1 * 2<sup>6</sup> 表示1乘以2的6次方, 也许这样更
清楚些, 即把原来表达中的指数7 6 &hellip; 0挪到了下面来表达)</p>

<p>现在, 却不能只用&#8217;tcp[13] 18&#8217;作为tcpdump的过滤表达式, 因为这将导致只选择含有SYN-ACK标志的数据包, 其他的都被丢弃.
提醒一下自己, 我们的目标是: 只要包的SYN标志被设置就行, 其他的标志我们不理会.</p>

<p>为了达到我们的目标, 我们需要把13号字节的二进制值与其他的一个数做AND操作(nt:逻辑与)来得到SYN比特位的值. 目标是:只要SYN 被设置
就行, 于是我们就把她与上13号字节的SYN值(nt: 00000010).</p>

<p>00010010 SYN-ACK 00000010 SYN
AND 00000010 (we want SYN) AND 00000010 (we want SYN)</p>

<hr />

<p>= 00000010 = 00000010</p>

<p>我们可以发现, 不管包的ACK或其他标志是否被设置, 以上的AND操作都会给我们相同的值, 其10进制表达就是2(2进制表达就是00000010).
从而我们知道, 对于带有SYN标志的数据包, 以下的表达式的结果总是真(true):</p>

<p>( ( value of octet 13 ) AND ( 2 ) ) ( 2 ) (nt: value of octet 13, 即13号字节的值)</p>

<p>灵感随之而来, 我们于是得到了如下的tcpdump 的过滤表达式
tcpdump -i xl0 &lsquo;tcp[13] &amp; 2 2&rsquo;</p>

<p>注意, 单引号或反斜杆(nt: 这里用的是单引号)不能省略, 这可以防止shell对&amp;的解释或替换.</p>

<ul>
<li>UDP 数据包</li>
</ul>


<p>UDP 数据包的显示格式，可通过rwho这个具体应用所产生的数据包来说明:
actinide.who > broadcast.who: udp 84</p>

<p>其含义为:actinide主机上的端口who向broadcast主机上的端口who发送了一个udp数据包(nt: actinide和broadcast都是指Internet地址).
这个数据包承载的用户数据为84个字节.</p>

<p>一些UDP服务可从数据包的源或目的端口来识别，也可从所显示的更高层协议信息来识别. 比如, Domain Name service requests(DNS 请求,
在RFC-1034/1035中), 和Sun RPC calls to NFS(对NFS服务器所发起的远程调用(nt: 即Sun RPC)，在RFC-1050中有对远程调用的描述).</p>

<p>UDP 名称服务请求</p>

<p>(注意:以下的描述假设你对Domain Service protoco(nt:在RFC-103中有所描述), 否则你会发现以下描述就是天书(nt:希腊文天书,
不必理会, 吓吓你的, 接着看就行))</p>

<p>名称服务请求有如下的格式:
src > dst: id op? flags qtype qclass name (len)
(nt: 从下文来看, 格式应该是src > dst: id op flags qtype qclass? name (len))
比如有一个实际显示为:
h2opolo.1538 > helios.domain: 3+ A? ucbvax.berkeley.edu. (37)</p>

<p>主机h2opolo 向helios 上运行的名称服务器查询ucbvax.berkeley.edu 的地址记录(nt: qtype等于A). 此查询本身的id号为&#8217;3&#8217;. 符号
&lsquo;+&#8217;意味着递归查询标志被设置(nt: dns服务器可向更高层dns服务器查询本服务器不包含的地址记录). 这个最终通过IP包发送的查询请求
数据长度为37字节, 其中不包括UDP和IP协议的头数据. 因为此查询操作为默认值(nt | rt: normal one的理解), op字段被省略.
如果op字段没被省略, 会被显示在&#8217;3&rsquo; 和&#8217;+&lsquo;之间. 同样, qclass也是默认值, C_IN, 从而也没被显示, 如果没被忽略, 她会被显示在&#8217;A&#8217;之后.</p>

<p>异常检查会在方括中显示出附加的域:　如果一个查询同时包含一个回应(nt: 可理解为, 对之前其他一个请求的回应), 并且此回应包含权威或附加记录段,　
ancount, nscout, arcount(nt: 具体字段含义需补充) 将被显示为&#8217;[na]&lsquo;, &rsquo;[nn]&lsquo;, &rsquo;[nau]&lsquo;, 其中n代表合适的计数. 如果包中以下
回应位(比如AA位, RA位, rcode位), 或者字节2或3中任何一个&#8217;必须为0&#8217;的位被置位(nt: 设置为1), &rsquo;[b2&amp;3]=x&#8217; 将被显示, 其中x表示
头部字节2与字节3进行与操作后的值.</p>

<p>UDP 名称服务应答</p>

<p>对名称服务应答的数据包，tcpdump会有如下的显示格式
src > dst: id op rcode flags a/n/au type class data (len)
比如具体显示如下:
helios.domain > h2opolo.1538: 3 3/3/7 A 128.32.137.3 (273)
helios.domain > h2opolo.1537: 2 NXDomain* 0/1/0 (97)</p>

<p>第一行表示: helios 对h2opolo 所发送的3号查询请求回应了3条回答记录(nt | rt: answer records), 3条名称服务器记录,
以及7条附加的记录. 第一个回答记录(nt: 3个回答记录中的第一个)类型为A(nt: 表示地址), 其数据为internet地址128.32.137.3.
此回应UDP数据包, 包含273字节的数据(不包含UPD和IP的头部数据). op字段和rcode字段被忽略(nt: op的实际值为Query, rcode, 即
response code的实际值为NoError), 同样被忽略的字段还有class 字段(nt | rt: 其值为C_IN, 这也是A类型记录默认取值)</p>

<p>第二行表示: helios 对h2opolo 所发送的2号查询请求做了回应. 回应中, rcode编码为NXDomain(nt: 表示不存在的域)), 没有回答记录,
但包含一个名称服务器记录, 不包含权威服务器记录(nt | ck: 从上文来看, 此处的authority records 就是上文中对应的additional
records). &lsquo;*&#8217;表示权威服务器回答标志被设置(nt: 从而additional records就表示的是authority records).
由于没有回答记录, type, class, data字段都被忽略.</p>

<p>flag字段还有可能出现其他一些字符, 比如&#8217;&ndash;&lsquo;(nt: 表示可递归地查询, 即RA 标志没有被设置), &rsquo;|&lsquo;(nt: 表示被截断的消息, 即TC 标志
被置位). 如果应答(nt | ct: 可理解为, 包含名称服务应答的UDP数据包, tcpdump知道这类数据包该怎样解析其数据)的&#8217;question&#8217;段一个条
目(entry)都不包含(nt: 每个条目的含义, 需补充),&rsquo;[nq]&lsquo; 会被打印出来.</p>

<p>要注意的是:名称服务器的请求和应答数据量比较大, 而默认的68字节的抓取长度(nt: snaplen, 可理解为tcpdump的一个设置选项)可能不足以抓取
数据包的全部内容. 如果你真的需要仔细查看名称服务器的负载, 可以通过tcpdump 的-s 选项来扩大snaplen值.</p>

<ul>
<li>SMB/CIFS 解码</li>
</ul>


<p>tcpdump 已可以对SMB/CIFS/NBT相关应用的数据包内容进行解码(nt: 分别为&#8217;Server Message Block Common&#8217;, &lsquo;Internet File System&rsquo;
&lsquo;在TCP/IP上实现的网络协议NETBIOS的简称&rsquo;. 这几个服务通常使用UDP的137/138以及TCP的139端口). 原来的对IPX和NetBEUI SMB数据包的
解码能力依然可以被使用(nt: NetBEUI为NETBIOS的增强版本).</p>

<p>tcpdump默认只按照最简约模式对相应数据包进行解码, 如果我们想要详尽的解码信息可以使用其-v 启动选现. 要注意的是, -v 会产生非常详细的信息,
比如对单一的一个SMB数据包, 将产生一屏幕或更多的信息, 所以此选项, 确有需要才使用.</p>

<p>关于SMB数据包格式的信息, 以及每个域的含义可以参看www.cifs.org 或者samba.org 镜像站点的pub/samba/specs/ 目录. linux 上的SMB 补丁
(nt | rt: patch)由 Andrew Tridgell (<a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x74;&#114;&#105;&#x64;&#103;&#x65;&#64;&#x73;&#97;&#109;&#x62;&#x61;&#x2e;&#x6f;&#x72;&#x67;">&#x74;&#x72;&#x69;&#x64;&#x67;&#x65;&#64;&#115;&#97;&#x6d;&#98;&#97;&#46;&#111;&#x72;&#x67;</a>)提供.</p>

<p>NFS 请求和回应</p>

<p>tcpdump对Sun NFS(网络文件系统)请求和回应的UDP数据包有如下格式的打印输出:
src.xid > dst.nfs: len op args
src.nfs > dst.xid: reply stat len op results</p>

<p>以下是一组具体的输出数据
sushi.6709 > wrl.nfs: 112 readlink fh 21,24/10.73165
wrl.nfs > sushi.6709: reply ok 40 readlink &ldquo;../var&rdquo;
sushi.201b > wrl.nfs:
144 lookup fh 9,74/4096.6878 &ldquo;xcolors&rdquo;
wrl.nfs > sushi.201b:
reply ok 128 lookup fh 9,74/4134.3150</p>

<p>第一行输出表明: 主机sushi向主机wrl发送了一个&#8217;交换请求&#8217;(nt: transaction), 此请求的id为6709(注意, 主机名字后是交换
请求id号, 而不是源端口号). 此请求数据为112字节, 其中不包括UDP和IP头部的长度. 操作类型为readlink(nt: 即此操作为读符号链接操作),
操作参数为fh 21,24/10.73165(nt: 可按实际运行环境, 解析如下, fd 表示描述的为文件句柄, 21,24 表示此句柄所对应设
备的主/从设备号对, 10表示此句柄所对应的i节点编号(nt:每个文件都会在操作系统中对应一个i节点, 限于unix类系统中),
73165是一个编号(nt: 可理解为标识此请求的一个随机数, 具体含义需补充)).</p>

<p>第二行中, wrl 做了&#8217;ok&#8217;的回应, 并且在results 字段中返回了sushi想要读的符号连接的真实目录(nt: 即sushi要求读的符号连接其实是一个目录).</p>

<p>第三行表明: sushi 再次请求 wrl 在&#8217;fh 9,74/4096.6878&#8217;所描述的目录中查找&#8217;xcolors&#8217;文件. 需要注意的是, 每行所显示的数据含义依赖于其中op字段的
类型(nt: 不同op 所对应args 含义不相同), 其格式遵循NFS 协议, 追求简洁明了.</p>

<p>如果tcpdump 的-v选项(详细打印选项) 被设置, 附加的信息将被显示. 比如:
sushi.1372a > wrl.nfs:
148 read fh 21,11/12.195 8192 bytes @ 24576
wrl.nfs > sushi.1372a:
reply ok 1472 read REG 100664 ids 417/0 sz 29388</p>

<p>(-v 选项一般还会打印出IP头部的TTL, ID， length, 以及fragmentation 域, 但在此例中, 都略过了(nt: 可理解为,简洁起见, 做了删减))
在第一行, sushi 请求wrl 从文件 21,11/12.195(nt: 格式在上面有描述)中, 自偏移24576字节处开始, 读取8192字节数据.
Wrl 回应读取成功; 由于第二行只是回应请求的开头片段, 所以只包含1472字节(其他的数据将在接着的reply片段中到来, 但这些数据包不会再有NFS
头, 甚至UDP头信息也为空(nt: 源和目的应该要有), 这将导致这些片段不能满足过滤条件, 从而没有被打印). -v 选项除了显示文件数据信息, 还会显示
附加显示文件属性信息: file type(文件类型, &lsquo;&#8217;REG&rsquo;&lsquo; 表示普通文件), file mode(文件存取模式, 8进制表示的), uid 和gid(nt: 文件属主和
组属主), file size (文件大小).</p>

<p>如果-v 标志被多次重复给出(nt: 如-vv)， tcpdump会显示更加详细的信息.</p>

<p>必须要注意的是, NFS 请求包中数据比较多, 如果tcpdump 的snaplen(nt: 抓取长度) 取太短将不能显示其详细信息. 可使用
&lsquo;-s 192&#8217;来增加snaplen, 这可用以监测NFS应用的网络负载(nt: traffic).</p>

<p>NFS 的回应包并不严格的紧随之前相应的请求包(nt: RPC operation). 从而, tcpdump 会跟踪最近收到的一系列请求包, 再通过其
交换序号(nt: transaction ID)与相应请求包相匹配. 这可能产生一个问题， 如果回应包来得太迟, 超出tcpdump 对相应请求包的跟踪范围,
该回应包将不能被分析.</p>

<ul>
<li>AFS 请求和回应</li>
</ul>


<p>AFS(nt: Andrew 文件系统, Transarc , 未知, 需补充)请求和回应有如下的答应</p>

<p>src.sport > dst.dport: rx packet-type
src.sport > dst.dport: rx packet-type service call call-name args
src.sport > dst.dport: rx packet-type service reply call-name args</p>

<p>elvis.7001 > pike.afsfs:
rx data fs call rename old fid 536876964/1/1 &ldquo;.newsrc.new&rdquo;
new fid 536876964/1/1 &ldquo;.newsrc&rdquo;
pike.afsfs > elvis.7001: rx data fs reply rename</p>

<p>在第一行, 主机elvis 向pike 发送了一个RX数据包.
这是一个对于文件服务的请求数据包(nt: RX data packet, 发送数据包 , 可理解为发送包过去, 从而请求对方的服务), 这也是一个RPC
调用的开始(nt: RPC, remote procedure call). 此RPC 请求pike 执行rename(nt: 重命名) 操作, 并指定了相关的参数:
原目录描述符为536876964/1/1, 原文件名为 &lsquo;.newsrc.new&rsquo;, 新目录描述符为536876964/1/1, 新文件名为 &lsquo;.newsrc&rsquo;.
主机pike 对此rename操作的RPC请求作了回应(回应表示rename操作成功, 因为回应的是包含数据内容的包而不是异常包).</p>

<p>一般来说, 所有的&#8217;AFS RPC&#8217;请求被显示时, 会被冠以一个名字(nt: 即decode, 解码), 这个名字往往就是RPC请求的操作名.
并且, 这些RPC请求的部分参数在显示时, 也会被冠以一个名字(nt | rt: 即decode, 解码, 一般来说也是取名也很直接, 比如,
一个interesting 参数, 显示的时候就会直接是&#8217;interesting&#8217;, 含义拗口, 需再翻).</p>

<p>这种显示格式的设计初衷为&#8217;一看就懂&#8217;, 但对于不熟悉AFS 和 RX 工作原理的人可能不是很
有用(nt: 还是不用管, 书面吓吓你的, 往下看就行).</p>

<p>如果 -v(详细)标志被重复给出(nt: 如-vv), tcpdump 会打印出确认包(nt: 可理解为, 与应答包有区别的包)以及附加头部信息
(nt: 可理解为, 所有包, 而不仅仅是确认包的附加头部信息), 比如, RX call ID(请求包中&#8217;请求调用&#8217;的ID),
call number(&lsquo;请求调用&#8217;的编号), sequence number(nt: 包顺序号),
serial number(nt | rt: 可理解为与包中数据相关的另一个顺信号, 具体含义需补充), 请求包的标识. (nt: 接下来一段为重复描述,
所以略去了), 此外确认包中的MTU协商信息也会被打印出来(nt: 确认包为相对于请求包的确认包, Maximum Transmission Unit, 最大传输单元).</p>

<p>如果 -v 选项被重复了三次(nt: 如-vvv), 那么AFS应用类型数据包的&#8217;安全索引&#8217;(&lsquo;security index&rsquo;)以及&#8217;服务索引&#8217;(&lsquo;service id&rsquo;)将会
被打印.</p>

<p>对于表示异常的数据包(nt: abort packet, 可理解为, 此包就是用来通知接受者某种异常已发生), tcpdump 会打印出错误号(error codes).
但对于Ubik beacon packets(nt: Ubik 灯塔指示包, Ubik可理解为特殊的通信协议, beacon packets, 灯塔数据包, 可理解为指明通信中
关键信息的一些数据包), 错误号不会被打印, 因为对于Ubik 协议, 异常数据包不是表示错误, 相反却是表示一种肯定应答(nt: 即, yes vote).</p>

<p>AFS 请求数据量大, 参数也多, 所以要求tcpdump的 snaplen 比较大, 一般可通过启动tcpdump时设置选项&#8217;-s 256&#8217; 来增大snaplen, 以
监测AFS 应用通信负载.</p>

<p>AFS 回应包并不显示标识RPC 属于何种远程调用. 从而, tcpdump 会跟踪最近一段时间内的请求包, 并通过call number(调用编号), service ID
(服务索引) 来匹配收到的回应包. 如果回应包不是针对最近一段时间内的请求包, tcpdump将无法解析该包.</p>

<ul>
<li>KIP AppleTalk协议</li>
</ul>


<p>(nt | rt: DDP in UDP可理解为, DDP, The AppleTalk Data Delivery Protocol,
相当于支持KIP AppleTalk协议栈的网络层协议, 而DDP 本身又是通过UDP来传输的,
即在UDP 上实现的用于其他网络的网络层，KIP AppleTalk是苹果公司开发的整套网络协议栈).</p>

<p>AppleTalk DDP 数据包被封装在UDP数据包中, 其解封装(nt: 相当于解码)和相应信息的转储也遵循DDP 包规则.
(nt:encapsulate, 封装, 相当于编码, de-encapsulate, 解封装, 相当于解码, dump, 转储, 通常就是指对其信息进行打印).</p>

<p>/etc/atalk.names 文件中包含了AppleTalk 网络和节点的数字标识到名称的对应关系. 其文件格式通常如下所示:
number name</p>

<p>1.254 ether
16.1 icsd-net
1.254.110 ace</p>

<p>头两行表示有两个AppleTalk 网络. 第三行给出了特定网络上的主机(一个主机会用3个字节来标识,
而一个网络的标识通常只有两个字节, 这也是两者标识的主要区别)(nt: 1.254.110 可理解为ether网络上的ace主机).
标识与其对应的名字之间必须要用空白分开. 除了以上内容, /etc/atalk.names中还包含空行以及注释行(以&#8217;#&lsquo;开始的行).</p>

<p>AppleTalk 完整网络地址将以如下格式显示:
net.host.port</p>

<p>以下为一段具体显示:
144.1.209.2 > icsd-net.112.220
office.2 > icsd-net.112.220
jssmag.149.235 > icsd-net.2</p>

<p>(如果/etc/atalk.names 文件不存在, 或者没有相应AppleTalk 主机/网络的条目, 数据包的网络地址将以数字形式显示).</p>

<p>在第一行中, 网络144.1上的节点209通过2端口,向网络icsd-net上监听在220端口的112节点发送了一个NBP应用数据包
(nt | rt: NBP, name binding protocol, 名称绑定协议, 从数据来看, NBP服务器会在端口2提供此服务.
&lsquo;DDP port 2&rsquo; 可理解为&#8217;DDP 对应传输层的端口2&#8217;, DDP本身没有端口的概念, 这点未确定, 需补充).</p>

<p>第二行与第一行类似, 只是源的全部地址可用&#8217;office&#8217;进行标识.
第三行表示: jssmag网络上的149节点通过235向icsd-net网络上的所有节点的2端口(NBP端口)发送了数据包.(需要注意的是,
在AppleTalk 网络中如果地址中没有节点, 则表示广播地址, 从而节点标识和网络标识最好在/etc/atalk.names有所区别.
nt: 否则一个标识x.port 无法确定x是指一个网络上所有主机的port口还是指定主机x的port口).</p>

<p>tcpdump 可解析NBP (名称绑定协议) and ATP (AppleTalk传输协议)数据包, 对于其他应用层的协议, 只会打印出相应协议名字(
如果此协议没有注册一个通用名字, 只会打印其协议号)以及数据包的大小.</p>

<p>NBP 数据包会按照如下格式显示:
icsd-net.112.220 > jssmag.2: nbp-lkup 190: &ldquo;=:LaserWriter@<em>&rdquo;
jssmag.209.2 > icsd-net.112.220: nbp-reply 190: &ldquo;RM1140:LaserWriter@</em>&rdquo; 250
techpit.2 > icsd-net.112.220: nbp-reply 190: &ldquo;techpit:LaserWriter@*&rdquo; 186</p>

<p>第一行表示: 网络icsd-net 中的节点112 通过220端口向网络jssmag 中所有节点的端口2发送了对&#8217;LaserWriter&#8217;的名称查询请求(nt:
此处名称可理解为一个资源的名称, 比如打印机). 此查询请求的序列号为190.</p>

<p>第二行表示: 网络jssmag 中的节点209 通过2端口向icsd-net.112节点的端口220进行了回应: 我有&#8217;LaserWriter&#8217;资源, 其资源名称
为&#8217;RM1140&#8217;, 并且在端口250上提供改资源的服务. 此回应的序列号为190, 对应之前查询的序列号.</p>

<p>第三行也是对第一行请求的回应: 节点techpit 通过2端口向icsd-net.112节点的端口220进行了回应:我有&#8217;LaserWriter&#8217;资源, 其资源名称
为&#8217;techpit&#8217;, 并且在端口186上提供改资源的服务. 此回应的序列号为190, 对应之前查询的序列号.</p>

<p>ATP 数据包的显示格式如下:
jssmag.209.165 > helios.132: atp-req 12266&lt;0-7> 0xae030001
helios.132 > jssmag.209.165: atp-resp 12266:0 (512) 0xae040000
helios.132 > jssmag.209.165: atp-resp 12266:1 (512) 0xae040000
helios.132 > jssmag.209.165: atp-resp 12266:2 (512) 0xae040000
helios.132 > jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
helios.132 > jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
helios.132 > jssmag.209.165: atp-resp 12266:6 (512) 0xae040000
helios.132 > jssmag.209.165: atp-resp<em>12266:7 (512) 0xae040000
jssmag.209.165 > helios.132: atp-req 12266&lt;3,5> 0xae030001
helios.132 > jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
helios.132 > jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
jssmag.209.165 > helios.132: atp-rel 12266&lt;0-7> 0xae030001
jssmag.209.133 > helios.132: atp-req</em> 12267&lt;0-7> 0xae030002</p>

<p>第一行表示节点 Jssmag.209 向节点helios 发送了一个会话编号为12266的请求包, 请求helios
回应8个数据包(这8个数据包的顺序号为0-7(nt: 顺序号与会话编号不同, 后者为一次完整传输的编号,
前者为该传输中每个数据包的编号. transaction, 会话, 通常也被叫做传输)). 行尾的16进制数字表示
该请求包中&#8217;userdata&#8217;域的值(nt: 从下文来看, 这并没有把所有用户数据都打印出来 ).</p>

<p>Helios 回应了8个512字节的数据包. 跟在会话编号(nt: 12266)后的数字表示该数据包在该会话中的顺序号.
括号中的数字表示该数据包中数据的大小, 这不包括atp 的头部. 在顺序号为7数据包(第8行)外带了一个&#8217;*&lsquo;号,
表示该数据包的EOM 标志被设置了.(nt: EOM, End Of Media, 可理解为, 表示一次会话的数据回应完毕).</p>

<p>接下来的第9行表示, Jssmag.209 又向helios 提出了请求: 顺序号为3以及5的数据包请重新传送. Helios 收到这个
请求后重新发送了这个两个数据包, jssmag.209 再次收到这两个数据包之后, 主动结束(release)了此会话.</p>

<p>在最后一行, jssmag.209 向helios 发送了开始下一次会话的请求包. 请求包中的&#8217;*&lsquo;表示该包的XO 标志没有被设置.
(nt: XO, exactly once, 可理解为在该会话中, 数据包在接受方只被精确地处理一次, 就算对方重复传送了该数据包,
接收方也只会处理一次, 这需要用到特别设计的数据包接收和处理机制).</p>

<ul>
<li>IP 数据包破碎</li>
</ul>


<p>(nt: 指把一个IP数据包分成多个IP数据包)</p>

<p>碎片IP数据包(nt: 即一个大的IP数据包破碎后生成的小IP数据包)有如下两种显示格式.
(frag id:size@offset+)
(frag id:size@offset)
(第一种格式表示, 此碎片之后还有后续碎片. 第二种格式表示, 此碎片为最后一个碎片.)</p>

<p>id 表示破碎编号(nt: 从下文来看, 会为每个要破碎的大IP包分配一个破碎编号, 以便区分每个小碎片是否由同一数据包破碎而来).
size 表示此碎片的大小 , 不包含碎片头部数据. offset表示此碎片所含数据在原始整个IP包中的偏移((nt: 从下文来看,
一个IP数据包是作为一个整体被破碎的, 包括头和数据, 而不只是数据被分割).</p>

<p>每个碎片都会使tcpdump产生相应的输出打印. 第一个碎片包含了高层协议的头数据(nt:从下文来看, 被破碎IP数据包中相应tcp头以及
IP头都放在了第一个碎片中 ), 从而tcpdump会针对第一个碎片显示这些信息, 并接着显示此碎片本身的信息. 其后的一些碎片并不包含
高层协议头信息, 从而只会在显示源和目的之后显示碎片本身的信息. 以下有一个例子: 这是一个从arizona.edu 到lbl-rtsg.arpa
途经CSNET网络(nt: CSNET connection 可理解为建立在CSNET 网络上的连接)的ftp应用通信片段:
arizona.ftp-data > rtsg.1170: . 1024:1332(308) ack 1 win 4096 (frag 595a:328@0+)
arizona > rtsg: (frag 595a:204@328)
rtsg.1170 > arizona.ftp-data: . ack 1536 win 2560</p>

<p>有几点值得注意:
第一, 第二行的打印中, 地址后面没有端口号.
这是因为TCP协议信息都放到了第一个碎片中, 当显示第二个碎片时, 我们无法知道此碎片所对应TCP包的顺序号.</p>

<p>第二, 从第一行的信息中, 可以发现arizona需要向rtsg发送308字节的用户数据, 而事实是, 相应IP包经破碎后会总共产生512字节
数据(第一个碎片包含308字节的数据, 第二个碎片包含204个字节的数据, 这超过了308字节). 如果你在查找数据包的顺序号空间中的
一些空洞(nt: hole,空洞, 指数据包之间的顺序号没有上下衔接上), 512这个数据就足够使你迷茫一阵(nt: 其实只要关注308就行,
不必关注破碎后的数据总量).</p>

<p>一个数据包(nt | rt: 指IP数据包)如果带有非IP破碎标志, 则显示时会在最后显示&#8217;(DF)&lsquo;.(nt: 意味着此IP包没有被破碎过).</p>

<ul>
<li>时间戳</li>
</ul>


<p>tcpdump的所有输出打印行中都会默认包含时间戳信息.
时间戳信息的显示格式如下
hh:mm:ss.frac　(nt: 小时:分钟:秒.(nt: frac未知, 需补充))
此时间戳的精度与内核时间精度一致,　反映的是内核第一次看到对应数据包的时间(nt: saw, 即可对该数据包进行操作).　
而数据包从物理线路传递到内核的时间, 以及内核花费在此包上的中断处理时间都没有算进来.</p>

<h2>命令使用</h2>

<p>tcpdump 采用命令行方式，它的命令格式为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>tcpdump <span class="o">[</span> -AdDeflLnNOpqRStuUvxX <span class="o">]</span> <span class="o">[</span> -c count <span class="o">]</span>
</span><span class='line'>           <span class="o">[</span> -C file_size <span class="o">]</span> <span class="o">[</span> -F file <span class="o">]</span>
</span><span class='line'>           <span class="o">[</span> -i interface <span class="o">]</span> <span class="o">[</span> -m module <span class="o">]</span> <span class="o">[</span> -M secret <span class="o">]</span>
</span><span class='line'>           <span class="o">[</span> -r file <span class="o">]</span> <span class="o">[</span> -s snaplen <span class="o">]</span> <span class="o">[</span> -T <span class="nb">type</span> <span class="o">]</span> <span class="o">[</span> -w file <span class="o">]</span>
</span><span class='line'>           <span class="o">[</span> -W filecount <span class="o">]</span>
</span><span class='line'>           <span class="o">[</span> -E spi@ipaddr algo:secret,...  <span class="o">]</span>
</span><span class='line'>           <span class="o">[</span> -y datalinktype <span class="o">]</span> <span class="o">[</span> -Z user <span class="o">]</span>
</span><span class='line'>           <span class="o">[</span> expression <span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>tcpdump 的简单选项介绍</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>-A  以ASCII码方式显示每一个数据包<span class="o">(</span>不会显示数据包中链路层头部信息<span class="o">)</span>. 在抓取包含网页数据的数据包时, 可方便查看数据<span class="o">(</span>nt: 即Handy <span class="k">for </span>capturing web pages<span class="o">)</span>.
</span><span class='line'>
</span><span class='line'>-c  count
</span><span class='line'>    tcpdump将在接受到count个数据包后退出.
</span><span class='line'>
</span><span class='line'>-C  file-size <span class="o">(</span>nt: 此选项用于配合-w file 选项使用<span class="o">)</span>
</span><span class='line'>    该选项使得tcpdump 在把原始数据包直接保存到文件中之前, 检查此文件大小是否超过file-size. 如果超过了, 将关闭此文件,另创一个文件继续用于原始数据包的记录. 新创建的文件名与-w 选项指定的文件名一致, 但文件名后多了一个数字.该数字会从1开始随着新创建文件的增多而增加. file-size的单位是百万字节<span class="o">(</span>nt: 这里指1,000,000个字节,并非1,048,576个字节, 后者是以1024字节为1k, 1024k字节为1M计算所得, 即1M<span class="o">=</span>1024 ＊ 1024 ＝ 1,048,576<span class="o">)</span>
</span><span class='line'>
</span><span class='line'>-d  以容易阅读的形式,在标准输出上打印出编排过的包匹配码, 随后tcpdump停止.<span class="o">(</span>nt | rt: human readable, 容易阅读的,通常是指以ascii码来打印一些信息. compiled, 编排过的. packet-matching code, 包匹配码,含义未知, 需补充<span class="o">)</span>
</span><span class='line'>
</span><span class='line'>-dd 以C语言的形式打印出包匹配码.
</span><span class='line'>
</span><span class='line'>-ddd 以十进制数的形式打印出包匹配码<span class="o">(</span>会在包匹配码之前有一个附加的<span class="s1">&#39;count&#39;</span>前缀<span class="o">)</span>.
</span><span class='line'>
</span><span class='line'>-D  打印系统中所有tcpdump可以在其上进行抓包的网络接口. 每一个接口会打印出数字编号, 相应的接口名字, 以及可能的一个网络接口描述. 其中网络接口名字和数字编号可以用在tcpdump 的-i flag 选项<span class="o">(</span>nt: 把名字或数字代替flag<span class="o">)</span>, 来指定要在其上抓包的网络接口.
</span><span class='line'>
</span><span class='line'>    此选项在不支持接口列表命令的系统上很有用<span class="o">(</span>nt: 比如, Windows 系统, 或缺乏 ifconfig -a 的UNIX系统<span class="o">)</span>; 接口的数字编号在windows 2000 或其后的系统中很有用, 因为这些系统上的接口名字比较复杂, 而不易使用.
</span><span class='line'>
</span><span class='line'>    如果tcpdump编译时所依赖的libpcap库太老,-D 选项不会被支持, 因为其中缺乏 pcap_findalldevs<span class="o">()</span>函数.
</span><span class='line'>
</span><span class='line'>-e  每行的打印输出中将包括数据包的数据链路层头部信息
</span><span class='line'>
</span><span class='line'>-E  spi@ipaddr algo:secret,...
</span><span class='line'>
</span><span class='line'>    可通过spi@ipaddr algo:secret 来解密IPsec ESP包<span class="o">(</span>nt | rt:IPsec Encapsulating Security Payload,IPsec 封装安全负载, IPsec可理解为, 一整套对ip数据包的加密协议, ESP 为整个IP 数据包或其中上层协议部分被加密后的数据,前者的工作模式称为隧道模式; 后者的工作模式称为传输模式 . 工作原理, 另需补充<span class="o">)</span>.
</span><span class='line'>
</span><span class='line'>    需要注意的是, 在终端启动tcpdump 时, 可以为IPv4 ESP packets 设置密钥<span class="o">(</span>secret）.
</span><span class='line'>
</span><span class='line'>    可用于加密的算法包括des-cbc, 3des-cbc, blowfish-cbc, rc3-cbc, cast128-cbc, 或者没有<span class="o">(</span>none<span class="o">)</span>.默认的是des-cbc<span class="o">(</span>nt: des, Data Encryption Standard, 数据加密标准, 加密算法未知, 另需补充<span class="o">)</span>.secret 为用于ESP 的密钥, 使用ASCII 字符串方式表达. 如果以 0x 开头, 该密钥将以16进制方式读入.
</span><span class='line'>
</span><span class='line'>    该选项中ESP 的定义遵循RFC2406, 而不是 RFC1827. 并且, 此选项只是用来调试的, 不推荐以真实密钥<span class="o">(</span>secret<span class="o">)</span>来使用该选项, 因为这样不安全: 在命令行中输入的secret 可以被其他人通过ps 等命令查看到.
</span><span class='line'>
</span><span class='line'>    除了以上的语法格式<span class="o">(</span>nt: 指spi@ipaddr algo:secret<span class="o">)</span>, 还可以在后面添加一个语法输入文件名字供tcpdump 使用<span class="o">(</span>nt：即把spi@ipaddr algo:secret,... 中...换成一个语法文件名<span class="o">)</span>. 此文件在接受到第一个ESP　包时会打开此文件, 所以最好此时把赋予tcpdump 的一些特权取消<span class="o">(</span>nt: 可理解为, 这样防范之后, 当该文件为恶意编写时,不至于造成过大损害<span class="o">)</span>.
</span><span class='line'>
</span><span class='line'>-f  显示外部的IPv4 地址时<span class="o">(</span>nt: foreign IPv4 addresses, 可理解为, 非本机ip地址<span class="o">)</span>, 采用数字方式而不是名字.<span class="o">(</span>此选项是用来对付Sun公司的NIS服务器的缺陷<span class="o">(</span>nt: NIS, 网络信息服务, tcpdump 显示外部地址的名字时会用到她提供的名称服务<span class="o">)</span>: 此NIS服务器在查询非本地地址名字时,常常会陷入无尽的查询循环<span class="o">)</span>.
</span><span class='line'>
</span><span class='line'>    由于对外部<span class="o">(</span>foreign<span class="o">)</span>IPv4地址的测试需要用到本地网络接口<span class="o">(</span>nt: tcpdump 抓包时用到的接口<span class="o">)</span>及其IPv4 地址和网络掩码. 如果此地址或网络掩码不可用, 或者此接口根本就没有设置相应网络地址和网络掩码<span class="o">(</span>nt: linux 下的 <span class="s1">&#39;any&#39;</span> 网络接口就不需要设置地址和掩码, 不过此<span class="s1">&#39;any&#39;</span>接口可以收到系统中所有接口的数据包<span class="o">)</span>, 该选项不能正常工作.
</span><span class='line'>
</span><span class='line'>-F  file
</span><span class='line'>    使用file 文件作为过滤条件表达式的输入, 此时命令行上的输入将被忽略.
</span><span class='line'>
</span><span class='line'>-i  interface
</span><span class='line'>
</span><span class='line'>    指定tcpdump 需要监听的接口.  如果没有指定, tcpdump 会从系统接口列表中搜寻编号最小的已配置好的接口<span class="o">(</span>不包括 loopback 接口<span class="o">)</span>.一但找到第一个符合条件的接口, 搜寻马上结束.
</span><span class='line'>
</span><span class='line'>    在采用2.2版本或之后版本内核的Linux 操作系统上, <span class="s1">&#39;any&#39;</span> 这个虚拟网络接口可被用来接收所有网络接口上的数据包<span class="o">(</span>nt: 这会包括目的是该网络接口的, 也包括目的不是该网络接口的<span class="o">)</span>. 需要注意的是如果真实网络接口不能工作在<span class="s1">&#39;混杂&#39;</span>模式<span class="o">(</span>promiscuous<span class="o">)</span>下,则无法在<span class="s1">&#39;any&#39;</span>这个虚拟的网络接口上抓取其数据包.
</span><span class='line'>
</span><span class='line'>    如果 -D 标志被指定, tcpdump会打印系统中的接口编号，而该编号就可用于此处的interface 参数.
</span><span class='line'>
</span><span class='line'>-l  对标准输出进行行缓冲<span class="o">(</span>nt: 使标准输出设备遇到一个换行符就马上把这行的内容打印出来<span class="o">)</span>.在需要同时观察抓包打印以及保存抓包记录的时候很有用. 比如, 可通过以下命令组合来达到此目的:
</span><span class='line'>    <span class="sb">``</span>tcpdump  -l  |  tee dat<span class="s1">&#39;&#39;</span> 或者 <span class="sb">``</span>tcpdump  -l   &gt; dat  &amp;  tail  -f  dat<span class="s1">&#39;&#39;</span>.<span class="o">(</span>nt: 前者使用tee来把tcpdump 的输出同时放到文件dat和标准输出中, 而后者通过重定向操作<span class="s1">&#39;&gt;&#39;</span>, 把tcpdump的输出放到dat 文件中, 同时通过tail把dat文件中的内容放到标准输出中<span class="o">)</span>
</span><span class='line'>
</span><span class='line'>-L  列出指定网络接口所支持的数据链路层的类型后退出.<span class="o">(</span>nt: 指定接口通过-i 来指定<span class="o">)</span>
</span><span class='line'>
</span><span class='line'>-m  module
</span><span class='line'>    通过module 指定的file 装载SMI MIB 模块<span class="o">(</span>nt: SMI，Structure of Management Information, 管理信息结构MIB, Management Information Base, 管理信息库. 可理解为, 这两者用于SNMP<span class="o">(</span>Simple Network Management Protoco<span class="o">)</span>协议数据包的抓取. 具体SNMP 的工作原理未知, 另需补充<span class="o">)</span>.
</span><span class='line'>
</span><span class='line'>    此选项可多次使用, 从而为tcpdump 装载不同的MIB 模块.
</span><span class='line'>
</span><span class='line'>-M  secret  如果TCP 数据包<span class="o">(</span>TCP segments<span class="o">)</span>有TCP-MD5选项<span class="o">(</span>在RFC 2385有相关描述<span class="o">)</span>, 则为其摘要的验证指定一个公共的密钥secret.
</span><span class='line'>
</span><span class='line'>-n  不对地址<span class="o">(</span>比如, 主机地址, 端口号<span class="o">)</span>进行数字表示到名字表示的转换.
</span><span class='line'>
</span><span class='line'>-N  不打印出host 的域名部分. 比如, 如果设置了此选现, tcpdump 将会打印<span class="s1">&#39;nic&#39;</span> 而不是 <span class="s1">&#39;nic.ddn.mil&#39;</span>.
</span><span class='line'>
</span><span class='line'>-O  不启用进行包匹配时所用的优化代码. 当怀疑某些bug是由优化代码引起的, 此选项将很有用.
</span><span class='line'>
</span><span class='line'>-p  一般情况下, 把网络接口设置为非<span class="s1">&#39;混杂&#39;</span>模式. 但必须注意 , 在特殊情况下此网络接口还是会以<span class="s1">&#39;混杂&#39;</span>模式来工作； 从而, <span class="s1">&#39;-p&#39;</span> 的设与不设, 不能当做以下选现的代名词:<span class="s1">&#39;ether host {local-hw-add}&#39;</span> 或  <span class="s1">&#39;ether broadcast&#39;</span><span class="o">(</span>nt: 前者表示只匹配以太网地址为host 的包, 后者表示匹配以太网地址为广播地址的数据包<span class="o">)</span>.
</span><span class='line'>
</span><span class='line'>-q  快速<span class="o">(</span>也许用<span class="s1">&#39;安静&#39;</span>更好?<span class="o">)</span>打印输出. 即打印很少的协议相关信息, 从而输出行都比较简短.
</span><span class='line'>
</span><span class='line'>-R  设定tcpdump 对 ESP/AH 数据包的解析按照 RFC1825而不是RFC1829<span class="o">(</span>nt: AH, 认证头, ESP， 安全负载封装, 这两者会用在IP包的安全传输机制中<span class="o">)</span>. 如果此选项被设置, tcpdump 将不会打印出<span class="s1">&#39;禁止中继&#39;</span>域<span class="o">(</span>nt: relay prevention field<span class="o">)</span>. 另外,由于ESP/AH规范中没有规定ESP/AH数据包必须拥有协议版本号域,所以tcpdump不能从收到的ESP/AH数据包中推导出协议版本号.
</span><span class='line'>
</span><span class='line'>-r  file
</span><span class='line'>    从文件file 中读取包数据. 如果file 字段为 <span class="s1">&#39;-&#39;</span> 符号, 则tcpdump 会从标准输入中读取包数据.
</span><span class='line'>
</span><span class='line'>-S  打印TCP 数据包的顺序号时, 使用绝对的顺序号, 而不是相对的顺序号.<span class="o">(</span>nt: 相对顺序号可理解为, 相对第一个TCP 包顺序号的差距,比如, 接受方收到第一个数据包的绝对顺序号为232323, 对于后来接收到的第2个,第3个数据包, tcpdump会打印其序列号为1, 2分别表示与第一个数据包的差距为1 和 2. 而如果此时-S 选项被设置, 对于后来接收到的第2个, 第3个数据包会打印出其绝对顺序号:232324, 232325<span class="o">)</span>.
</span><span class='line'>
</span><span class='line'>-s  snaplen
</span><span class='line'>    设置tcpdump的数据包抓取长度为snaplen, 如果不设置默认将会是68字节<span class="o">(</span>而支持网络接口分接头<span class="o">(</span>nt: NIT, 上文已有描述,可搜索<span class="s1">&#39;网络接口分接头&#39;</span>关键字找到那里<span class="o">)</span>的SunOS系列操作系统中默认的也是最小值是96<span class="o">)</span>.68字节对于IP, ICMP<span class="o">(</span>nt: Internet Control Message Protocol,因特网控制报文协议<span class="o">)</span>, TCP 以及 UDP 协议的报文已足够, 但对于名称服务<span class="o">(</span>nt: 可理解为dns, nis等服务<span class="o">)</span>, NFS服务相关的数据包会产生包截短. 如果产生包截短这种情况, tcpdump的相应打印输出行中会出现<span class="s1">&#39;&#39;</span><span class="o">[</span>|proto<span class="o">]</span><span class="s1">&#39;&#39;</span>的标志（proto 实际会显示为被截短的数据包的相关协议层次<span class="o">)</span>. 需要注意的是, 采用长的抓取长度<span class="o">(</span>nt: snaplen比较大<span class="o">)</span>, 会增加包的处理时间, 并且会减少tcpdump 可缓存的数据包的数量， 从而会导致数据包的丢失. 所以, 在能抓取我们想要的包的前提下, 抓取长度越小越好.把snaplen 设置为0 意味着让tcpdump自动选择合适的长度来抓取数据包.
</span><span class='line'>
</span><span class='line'>-T  <span class="nb">type</span>
</span><span class='line'>    强制tcpdump按type指定的协议所描述的包结构来分析收到的数据包.  目前已知的type 可取的协议为:
</span><span class='line'>    aodv <span class="o">(</span>Ad-hoc On-demand Distance Vector protocol, 按需距离向量路由协议, 在Ad hoc<span class="o">(</span>点对点模式<span class="o">)</span>网络中使用<span class="o">)</span>,
</span><span class='line'>    cnfp <span class="o">(</span>Cisco  NetFlow  protocol<span class="o">)</span>,  rpc<span class="o">(</span>Remote Procedure Call<span class="o">)</span>, rtp <span class="o">(</span>Real-Time Applications protocol<span class="o">)</span>,
</span><span class='line'>    rtcp <span class="o">(</span>Real-Time Applications con-trol protocol<span class="o">)</span>, snmp <span class="o">(</span>Simple Network Management Protocol<span class="o">)</span>,
</span><span class='line'>    tftp <span class="o">(</span>Trivial File Transfer Protocol, 碎文件协议<span class="o">)</span>, vat <span class="o">(</span>Visual Audio Tool, 可用于在internet 上进行电
</span><span class='line'>    视电话会议的应用层协议<span class="o">)</span>, 以及wb <span class="o">(</span>distributed White Board, 可用于网络会议的应用层协议<span class="o">)</span>.
</span><span class='line'>
</span><span class='line'>-t     在每行输出中不打印时间戳
</span><span class='line'>
</span><span class='line'>-tt    不对每行输出的时间进行格式处理<span class="o">(</span>nt: 这种格式一眼可能看不出其含义, 如时间戳打印成1261798315<span class="o">)</span>
</span><span class='line'>
</span><span class='line'>-ttt   tcpdump 输出时, 每两行打印之间会延迟一个段时间<span class="o">(</span>以毫秒为单位<span class="o">)</span>
</span><span class='line'>
</span><span class='line'>-tttt  在每行打印的时间戳之前添加日期的打印
</span><span class='line'>
</span><span class='line'>-u     打印出未加密的NFS 句柄<span class="o">(</span>nt: handle可理解为NFS 中使用的文件句柄, 这将包括文件夹和文件夹中的文件<span class="o">)</span>
</span><span class='line'>
</span><span class='line'>-U    使得当tcpdump在使用-w 选项时, 其文件写入与包的保存同步.<span class="o">(</span>nt: 即, 当每个数据包被保存时, 它将及时被写入文件中,而不是等文件的输出缓冲已满时才真正写入此文件<span class="o">)</span>
</span><span class='line'>
</span><span class='line'>      -U 标志在老版本的libcap库<span class="o">(</span>nt: tcpdump 所依赖的报文捕获库<span class="o">)</span>上不起作用, 因为其中缺乏pcap_cump_flush<span class="o">()</span>函数.
</span><span class='line'>
</span><span class='line'>-v    当分析和打印的时候, 产生详细的输出. 比如, 包的生存时间, 标识, 总长度以及IP包的一些选项. 这也会打开一些附加的包完整性检测, 比如对IP或ICMP包头部的校验和.
</span><span class='line'>
</span><span class='line'>-vv   产生比-v更详细的输出. 比如, NFS回应包中的附加域将会被打印, SMB数据包也会被完全解码.
</span><span class='line'>
</span><span class='line'>-vvv  产生比-vv更详细的输出. 比如, telent 时所使用的SB, SE 选项将会被打印, 如果telnet同时使用的是图形界面,
</span><span class='line'>      其相应的图形选项将会以16进制的方式打印出来<span class="o">(</span>nt: telnet 的SB,SE选项含义未知, 另需补充<span class="o">)</span>.
</span><span class='line'>
</span><span class='line'>-w    把包数据直接写入文件而不进行分析和打印输出. 这些包数据可在随后通过-r 选项来重新读入并进行分析和打印.
</span><span class='line'>
</span><span class='line'>-W    filecount
</span><span class='line'>      此选项与-C 选项配合使用, 这将限制可打开的文件数目, 并且当文件数据超过这里设置的限制时, 依次循环替代之前的文件, 这相当于一个拥有filecount 个文件的文件缓冲池. 同时, 该选项会使得每个文件名的开头会出现足够多并用来占位的0, 这可以方便这些文件被正确的排序.
</span><span class='line'>
</span><span class='line'>-x    当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制打印出每个包的数据<span class="o">(</span>但不包括连接层的头部<span class="o">)</span>.总共打印的数据大小不会超过整个数据包的大小与snaplen 中的最小值. 必须要注意的是, 如果高层协议数据没有snaplen 这么长,并且数据链路层<span class="o">(</span>比如, Ethernet层<span class="o">)</span>有填充数据, 则这些填充数据也会被打印.<span class="o">(</span>nt: so <span class="k">for </span>link  layers  that pad, 未能衔接理解和翻译, 需补充 <span class="o">)</span>
</span><span class='line'>
</span><span class='line'>-xx   tcpdump 会打印每个包的头部数据, 同时会以16进制打印出每个包的数据, 其中包括数据链路层的头部.
</span><span class='line'>
</span><span class='line'>-X    当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制和ASCII码形式打印出每个包的数据<span class="o">(</span>但不包括连接层的头部<span class="o">)</span>.这对于分析一些新协议的数据包很方便.
</span><span class='line'>
</span><span class='line'>-XX   当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制和ASCII码形式打印出每个包的数据, 其中包括数据链路层的头部.这对于分析一些新协议的数据包很方便.
</span><span class='line'>
</span><span class='line'>-y    datalinktype
</span><span class='line'>      设置tcpdump 只捕获数据链路层协议类型是datalinktype的数据包
</span><span class='line'>
</span><span class='line'>-Z    user
</span><span class='line'>      使tcpdump 放弃自己的超级权限<span class="o">(</span>如果以root用户启动tcpdump, tcpdump将会有超级用户权限<span class="o">)</span>, 并把当前tcpdump的用户ID设置为user, 组ID设置为user首要所属组的ID<span class="o">(</span>nt: tcpdump 此处可理解为tcpdump 运行之后对应的进程<span class="o">)</span>
</span><span class='line'>
</span><span class='line'>      此选项也可在编译的时候被设置为默认打开.<span class="o">(</span>nt: 此时user 的取值未知, 需补充<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>tcpdump 条件表达式</li>
</ul>


<p>该表达式用于决定哪些数据包将被打印. 如果不给定条件表达式, 网络上所有被捕获的包都会被打印,否则, 只有满足条件表达式的数据包被打印.(nt: all packets, 可理解为, 所有被指定接口捕获的数据包).</p>

<p>表达式由一个或多个&#8217;表达元&#8217;组成(nt: primitive, 表达元, 可理解为组成表达式的基本元素). 一个表达元通常由一个或多个修饰符(qualifiers)后跟一个名字或数字表示的id组成(nt: 即, &lsquo;qualifiers id&rsquo;).有三种不同类型的修饰符:type, dir以及 proto.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nb">type</span> 修饰符指定id 所代表的对象类型, id可以是名字也可以是数字. 可选的对象类型有: host, net, port 以及portrange<span class="o">(</span>nt: host 表明id表示主机, net 表明id是网络, port 表明id是端而portrange 表明id 是一个端口范围<span class="o">)</span>.  如, <span class="s1">&#39;host foo&#39;</span>, <span class="s1">&#39;net 128.3&#39;</span>, <span class="s1">&#39;port 20&#39;</span>, <span class="s1">&#39;portrange 6000-6008&#39;</span><span class="o">(</span>nt: 分别表示主机 foo,网络 128.3, 端口 20, 端口范围 6000-6008<span class="o">)</span>. 如果不指定type 修饰符, id默认的修饰符为host.
</span><span class='line'>
</span><span class='line'>dir 修饰符描述id 所对应的传输方向, 即发往id 还是从id 接收（nt: 而id 到底指什么需要看其前面的type 修饰符）.可取的方向为: src, dst, src 或 dst, src并且dst.<span class="o">(</span>nt:分别表示, id是传输源, id是传输目的, id是传输源或者传输目的, id是传输源并且是传输目的<span class="o">)</span>. 例如, <span class="s1">&#39;src foo&#39;</span>,<span class="s1">&#39;dst net 128.3&#39;</span>, <span class="s1">&#39;src or dst port ftp-data&#39;</span>.<span class="o">(</span>nt: 分别表示符合条件的数据包中, 源主机是foo, 目的网络是128.3, 源或目的端口为 ftp-data<span class="o">)</span>.如果不指定dir修饰符, id 默认的修饰符为src 或 dst.对于链路层的协议,比如SLIP<span class="o">(</span>nt: Serial Line InternetProtocol, 串联线路网际网络协议<span class="o">)</span>, 以及linux下指定<span class="s1">&#39;any&#39;</span> 设备, 并指定<span class="s1">&#39;cooked&#39;</span><span class="o">(</span>nt | rt: cooked 含义未知, 需补充<span class="o">)</span> 抓取类型, 或其他设备类型,可以用<span class="s1">&#39;inbound&#39;</span> 和 <span class="s1">&#39;outbount&#39;</span> 修饰符来指定想要的传输方向.
</span><span class='line'>
</span><span class='line'>proto 修饰符描述id 所属的协议. 可选的协议有: ether, fddi, tr, wlan, ip, ip6, arp, rarp, decnet, tcp以及 upd.<span class="o">(</span>nt | rt: ether, fddi, tr, 具体含义未知, 需补充. 可理解为物理以太网传输协议, 光纤分布数据网传输协议,以及用于路由跟踪的协议.  wlan, 无线局域网协议; ip,ip6 即通常的TCP/IP协议栈中所使用的ipv4以及ipv6网络层协议;arp, rarp 即地址解析协议,反向地址解析协议; decnet, Digital Equipment Corporation开发的, 最早用于PDP-11 机器互联的网络协议; tcp and udp, 即通常TCP/IP协议栈中的两个传输层协议<span class="o">)</span>.
</span><span class='line'>
</span><span class='line'>    例如, <span class="sb">`</span>ether src foo<span class="s1">&#39;, `arp net 128.3&#39;</span>, <span class="sb">`</span>tcp port 21<span class="s1">&#39;, `udp portrange 7000-7009&#39;</span>分别表示 <span class="s1">&#39;从以太网地址foo 来的数据包&#39;</span>,<span class="s1">&#39;发往或来自128.3网络的arp协议数据包&#39;</span>, <span class="s1">&#39;发送或接收端口为21的tcp协议数据包&#39;</span>, <span class="s1">&#39;发送或接收端口范围为7000-7009的udp协议数据包&#39;</span>.
</span><span class='line'>
</span><span class='line'>    如果不指定proto 修饰符, 则默认为与相应type匹配的修饰符. 例如, <span class="s1">&#39;src foo&#39;</span> 含义是 <span class="s1">&#39;(ip or arp or rarp) src foo&#39;</span> <span class="o">(</span>nt: 即, 来自主机foo的ip/arp/rarp协议数据包, 默认type为host<span class="o">)</span>,<span class="sb">`</span>net bar<span class="s1">&#39; 含义是`(ip  or  arp  or rarp) net bar&#39;</span><span class="o">(</span>nt: 即, 来自或发往bar网络的ip/arp/rarp协议数据包<span class="o">)</span>,<span class="sb">`</span>port 53<span class="s1">&#39; 含义是 `(tcp or udp) port 53&#39;</span><span class="o">(</span>nt: 即, 发送或接收端口为53的tcp/udp协议数据包<span class="o">)</span>.<span class="o">(</span>nt: 由于tcpdump 直接通过数据链路层的 BSD 数据包过滤器或 DLPI<span class="o">(</span>datalink provider interface, 数据链层提供者接口<span class="o">)</span>来直接获得网络数据包, 其可抓取的数据包可涵盖上层的各种协议, 包括arp, rarp, icmp<span class="o">(</span>因特网控制报文协议<span class="o">)</span>,ip, ip6, tcp, udp, sctp<span class="o">(</span>流控制传输协议<span class="o">)</span>.
</span><span class='line'>
</span><span class='line'>    对于修饰符后跟id 的格式,可理解为, <span class="nb">type </span>id 是对包最基本的过滤条件: 即对包相关的主机, 网络, 端口的限制;dir 表示对包的传送方向的限制; proto表示对包相关的协议限制<span class="o">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="s1">&#39;fddi&#39;</span><span class="o">(</span>nt: Fiber Distributed Data Interface<span class="o">)</span> 实际上与<span class="s1">&#39;ether&#39;</span> 含义一样: tcpdump 会把他们当作一种<span class="s1">&#39;&#39;</span>指定网络接口上的数据链路层协议<span class="s1">&#39;&#39;</span>. 如同ehter网<span class="o">(</span>以太网<span class="o">)</span>, FDDI 的头部通常也会有源, 目的, 以及包类型, 从而可以像ether网数据包一样对这些域进行过滤. 此外, FDDI 头部还有其他的域, 但不能被放到表达式中用来过滤
</span><span class='line'>
</span><span class='line'>    同样, <span class="s1">&#39;tr&#39;</span> 和 <span class="s1">&#39;wlan&#39;</span> 也和 <span class="s1">&#39;ether&#39;</span> 含义一致, 上一段对fddi 的描述同样适用于tr<span class="o">(</span>Token Ring<span class="o">)</span> 和wlan<span class="o">(</span>802.11 wireless LAN<span class="o">)</span>的头部. 对于802.11 协议数据包的头部, 目的域称为DA, 源域称为 SA;而其中的 BSSID, RA, TA 域<span class="o">(</span>nt | rt: 具体含义需补充<span class="o">)</span>不会被检测<span class="o">(</span>nt: 不能被用于包过虑表达式中<span class="o">)</span>.
</span></code></pre></td></tr></table></div></figure>


<p>除以上所描述的表达元(&lsquo;primitive&rsquo;)， 还有其他形式的表达元, 并且与上述表达元格式不同. 比如: gateway, broadcast, less, greater以及算术表达式(nt: 其中每一个都算一种新的表达元). 下面将会对这些表达元进行说明.</p>

<p>表达元之间还可以通过关键字and, or 以及 not 进行连接, 从而可组成比较复杂的条件表达式. 比如,`host foo and not port ftp and not port ftp-data&#8217;(nt: 其过滤条件可理解为, 数据包的主机为foo,并且端口不是ftp(端口21) 和ftp-data(端口20, 常用端口和名字的对应可在linux 系统中的/etc/service 文件中找到)).</p>

<p>为了表示方便, 同样的修饰符可以被省略, 如&#8217;tcp dst port ftp or ftp-data or domain&#8217; 与以下的表达式含义相同&#8217;tcp dst port ftp or tcp dst port ftp-data or tcp dst port domain&#8217;.(nt: 其过滤条件可理解为,包的协议为tcp, 目的端口为ftp 或 ftp-data 或 domain(端口53) ).</p>

<p>借助括号以及相应操作符,可把表达元组合在一起使用(由于括号是shell的特殊字符, 所以在shell脚本或终端中使用时必须对括号进行转义, 即&#8217;(&lsquo; 与&rsquo;)&lsquo;需要分别表达成&rsquo;(&lsquo; 与 &rsquo;)&lsquo;).</p>

<p>有效的操作符有:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>否定操作 <span class="o">(</span><span class="sb">`</span>!<span class="s1">&#39; 或 `not&#39;</span><span class="o">)</span>
</span><span class='line'>与操作<span class="o">(</span><span class="sb">`</span><span class="o">&amp;&amp;</span><span class="s1">&#39; 或 `and&#39;</span><span class="o">)</span>
</span><span class='line'>或操作<span class="o">(</span><span class="sb">`</span><span class="o">||</span><span class="s1">&#39; 或 `or&#39;</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>否定操作符的优先级别最高. 与操作和或操作优先级别相同, 并且二者的结合顺序是从左到右. 要注意的是, 表达&#8217;与操作&#8217;时,</p>

<p>需要显式写出&#8217;and&#8217;操作符, 而不只是把前后表达元并列放置(nt: 二者中间的&#8217;and&#8217; 操作符不可省略).</p>

<p>如果一个标识符前没有关键字, 则表达式的解析过程中最近用过的关键字(往往也是从左往右距离标识符最近的关键字)将被使用.比如,</p>

<pre><code>not host vs and ace
</code></pre>

<p>是以下表达的精简:</p>

<pre><code>not host vs and host ace
</code></pre>

<p>而不是not (host vs or ace).(nt: 前两者表示, 所需数据包不是来自或发往host vs, 而是来自或发往ace.而后者表示数据包只要不是来自或发往vs或ac都符合要求)</p>

<p>整个条件表达式可以被当作一个单独的字符串参数也可以被当作空格分割的多个参数传入tcpdump, 后者更方便些. 通常, 如果表达式中包含元字符(nt: 如正则表达式中的&#8217;*&lsquo;, &rsquo;.&lsquo;以及shell中的&rsquo;(&lsquo;等字符)， 最好还是使用单独字符串的方式传入. 这时,整个表达式需要被单引号括起来. 多参数的传入方式中, 所有参数最终还是被空格串联在一起, 作为一个字符串被解析.</p>

<h2>附录：tcpdump 的表达元</h2>

<p>(nt: True 在以下的描述中含义为: 相应条件表达式中只含有以下所列的一个特定表达元, 此时表达式为真, 即条件得到满足)</p>

<p>dst host host
如果IPv4/v6 数据包的目的域是host, 则与此对应的条件表达式为真.host 可以是一个ip地址, 也可以是一个主机名.
src host host
如果IPv4/v6 数据包的源域是host, 则与此对应的条件表达式为真.
host 可以是一个ip地址, 也可以是一个主机名.
host host</p>

<p>如果IPv4/v6数据包的源或目的地址是 host, 则与此对应的条件表达式为真.以上的几个host 表达式之前可以添加以下关键字:ip, arp, rarp, 以及 ip6.比如:
ip host host
也可以表达为:
ether proto \ip and host host(nt: 这种表达方式在下面有说明, 其中ip之前需要有\来转义,因为ip 对tcpdump 来说已经是一个关键字了.)</p>

<p>如果host 是一个拥有多个IP 的主机, 那么任何一个地址都会用于包的匹配(nt: 即发向host 的数据包的目的地址可以是这几个IP中的任何一个, 从host 接收的数据包的源地址也可以是这几个IP中的任何一个).</p>

<p>ether dst ehost
如果数据包(nt: 指tcpdump 可抓取的数据包, 包括ip 数据包, tcp数据包)的以太网目标地址是ehost,则与此对应的条件表达式为真. Ehost 可以是/etc/ethers 文件中的名字或一个数字地址(nt: 可通过 man ethers 看到对/etc/ethers 文件的描述, 样例中用的是数字地址)</p>

<p>ether src ehost
如果数据包的以太网源地址是ehost, 则与此对应的条件表达式为真.</p>

<p>ether host ehost
如果数据包的以太网源地址或目标地址是ehost, 则与此对应的条件表达式为真.</p>

<p>gateway host
如果数据包的网关地址是host, 则与此对应的条件表达式为真. 需要注意的是, 这里的网关地址是指以太网地址, 而不是IP 地址(nt | rt: I.e., 例如, 可理解为&#8217;注意&#8217;.the Ethernet source or destination address, 以太网源和目标地址, 可理解为, 指代上句中的&#8217;网关地址&#8217; ).host 必须是名字而不是数字, 并且必须在机器的&#8217;主机名-ip地址&#8217;以及&#8217;主机名-以太地址&#8217;两大映射关系中 有其条目(前一映射关系可通过/etc/hosts文件, DNS 或 NIS得到, 而后一映射关系可通过/etc/ethers 文件得到. nt: /etc/ethers并不一定存在 , 可通过man ethers 看到其数据格式, 如何创建该文件, 未知,需补充).也就是说host 的含义是 ether host ehost 而不是 host host, 并且ehost必须是名字而不是数字.
目前, 该选项在支持IPv6地址格式的配置环境中不起作用(nt: configuration, 配置环境, 可理解为,通信双方的网络配置).</p>

<p>dst net net
如果数据包的目标地址(IPv4或IPv6格式)的网络号字段为 net, 则与此对应的条件表达式为真.
net 可以是从网络数据库文件/etc/networks 中的名字, 也可以是一个数字形式的网络编号.</p>

<p>一个数字IPv4 网络编号将以点分四元组(比如, 192.168.1.0), 或点分三元组(比如, 192.168.1 ), 或点分二元组(比如, 172.16), 或单一单元组(比如, 10)来表达;</p>

<p>对应于这四种情况的网络掩码分别是:四元组:255.255.255.255(这也意味着对net 的匹配如同对主机地址(host)的匹配:地址的四个部分都用到了),三元组:255.255.255.0, 二元组: 255.255.0.0, 一元组:255.0.0.0.</p>

<p>对于IPv6 的地址格式, 网络编号必须全部写出来(8个部分必须全部写出来); 相应网络掩码为:
ff:ff:ff:ff:ff:ff:ff:ff, 所以IPv6 的网络匹配是真正的&#8217;host&#8217;方式的匹配(nt | rt | rc:地址的8个部分都会用到,是否不属于网络的字节填写0, 需接下来补充), 但同时需要一个网络掩码长度参数来具体指定前面多少字节为网络掩码(nt: 可通过下面的net net/len 来指定)</p>

<p>src net net
如果数据包的源地址(IPv4或IPv6格式)的网络号字段为 net, 则与此对应的条件表达式为真.</p>

<p>net net
如果数据包的源或目的地址(IPv4或IPv6格式)的网络号字段为 net, 则与此对应的条件表达式为真.</p>

<p>net net mask netmask
如果数据包的源或目的地址(IPv4或IPv6格式)的网络掩码与netmask 匹配, 则与此对应的条件表达式为真.此选项之前还可以配合src和dst来匹配源网络地址或目标网络地址(nt: 比如 src net net mask 255.255.255.0).该选项对于ipv6 网络地址无效.</p>

<p>net net/len
如果数据包的源或目的地址(IPv4或IPv6格式)的网络编号字段的比特数与len相同, 则与此对应的条件表达式为真.此选项之前还可以配合src和dst来匹配源网络地址或目标网络地址(nt | rt | tt: src net net/24, 表示需要匹配源地址的网络编号有24位的数据包).</p>

<p>dst port port
如果数据包(包括ip/tcp, ip/udp, ip6/tcp or ip6/udp协议)的目的端口为port, 则与此对应的条件表达式为真.port 可以是一个数字也可以是一个名字(相应名字可以在/etc/services 中找到该名字, 也可以通过man tcp 和man udp来得到相关描述信息 ). 如果使用名字, 则该名字对应的端口号和相应使用的协议都会被检查. 如果只是使用一个数字端口号,则只有相应端口号被检查(比如, dst port 513 将会使tcpdump抓取tcp协议的login 服务和udp协议的who 服务数据包, 而port domain 将会使tcpdump 抓取tcp协议的domain 服务数据包, 以及udp 协议的domain 数据包)(nt | rt: ambiguous name is used 不可理解, 需补充).</p>

<p>src port port
如果数据包的源端口为port, 则与此对应的条件表达式为真.</p>

<p>port port
如果数据包的源或目的端口为port, 则与此对应的条件表达式为真.</p>

<p>dst portrange port1-port2
如果数据包(包括ip/tcp, ip/udp, ip6/tcp or ip6/udp协议)的目的端口属于port1到port2这个端口范围(包括port1, port2), 则与此对应的条件表达式为真. tcpdump 对port1 和port2 解析与对port 的解析一致(nt:在dst port port 选项的描述中有说明).</p>

<p>src portrange port1-port2
如果数据包的源端口属于port1到port2这个端口范围(包括 port1, port2), 则与此对应的条件表达式为真.</p>

<p>portrange port1-port2
如果数据包的源端口或目的端口属于port1到port2这个端口范围(包括 port1, port2), 则与此对应的条件表达式为真.</p>

<p>以上关于port 的选项都可以在其前面添加关键字:tcp 或者udp, 比如:
tcp src port port
这将使tcpdump 只抓取源端口是port 的tcp数据包.</p>

<p>less length
如果数据包的长度比length 小或等于length, 则与此对应的条件表达式为真. 这与&#8217;len &lt;= length&#8217; 的含义一致.</p>

<p>greater length
如果数据包的长度比length 大或等于length, 则与此对应的条件表达式为真. 这与&#8217;len >= length&#8217; 的含义一致.</p>

<p>ip proto protocol
如果数据包为ipv4数据包并且其协议类型为protocol, 则与此对应的条件表达式为真.
Protocol 可以是一个数字也可以是名字, 比如:icmp6, igmp, igrp(nt: Interior Gateway Routing Protocol,内部网关路由协议), pim(Protocol Independent Multicast, 独立组播协议, 应用于组播路由器),ah, esp(nt: ah, 认证头, esp 安全负载封装, 这两者会用在IP包的安全传输机制中 ), vrrp(Virtual Router Redundancy Protocol, 虚拟路由器冗余协议), udp, or tcp. 由于tcp , udp 以及icmp是tcpdump 的关键字,所以在这些协议名字之前必须要用\来进行转义(如果在C-shell 中需要用\来进行转义). 注意此表达元不会把数据包中协议头链中所有协议头内容全部打印出来(nt: 实际上只会打印指定协议的一些头部信息, 比如可以用tcpdump -i eth0 &lsquo;ip proto \tcp and host 192.168.3.144&rsquo;, 则只打印主机192.168.3.144 发出或接收的数据包中tcp 协议头所包含的信息)</p>

<p>ip6 proto protocol
如果数据包为ipv6数据包并且其协议类型为protocol, 则与此对应的条件表达式为真.
注意此表达元不会把数据包中协议头链中所有协议头内容全部打印出来</p>

<p>ip6 protochain protocol
如果数据包为ipv6数据包并且其协议链中包含类型为protocol协议头, 则与此对应的条件表达式为真. 比如,
ip6 protochain 6</p>

<p>将匹配其协议头链中拥有TCP 协议头的IPv6数据包.此数据包的IPv6头和TCP头之间可能还会包含验证头, 路由头, 或者逐跳寻径选项头.
由此所触发的相应BPF(Berkeley Packets Filter, 可理解为, 在数据链路层提供数据包过滤的一种机制)代码比较繁琐,
并且BPF优化代码也未能照顾到此部分, 从而此选项所触发的包匹配可能会比较慢.</p>

<p>ip protochain protocol
与ip6 protochain protocol 含义相同, 但这用在IPv4数据包.</p>

<p>ether broadcast
如果数据包是以太网广播数据包, 则与此对应的条件表达式为真. ether 关键字是可选的.</p>

<p>ip broadcast
如果数据包是IPv4广播数据包, 则与此对应的条件表达式为真. 这将使tcpdump 检查广播地址是否符合全0和全1的一些约定,并查找网络接口的网络掩码(网络接口为当时在其上抓包的网络接口).</p>

<p>如果抓包所在网络接口的网络掩码不合法, 或者此接口根本就没有设置相应网络地址和网络， 亦或是在linux下的&#8217;any&#8217;网络接口上抓包(此&#8217;any&#8217;接口可以收到系统中不止一个接口的数据包(nt: 实际上, 可理解为系统中所有可用的接口)),网络掩码的检查不能正常进行.</p>

<p>ether multicast
如果数据包是一个以太网多点广播数据包(nt: 多点广播, 可理解为把消息同时传递给一组目的地址, 而不是网络中所有地址,后者为可称为广播(broadcast)), 则与此对应的条件表达式为真. 关键字ether 可以省略. 此选项的含义与以下条件表达式含义一致:`ether[0] &amp; 1 != 0&#8217;(nt: 可理解为, 以太网数据包中第0个字节的最低位是1, 这意味这是一个多点广播数据包).</p>

<p>ip multicast
如果数据包是ipv4多点广播数据包, 则与此对应的条件表达式为真.</p>

<p>ip6 multicast
如果数据包是ipv6多点广播数据包, 则与此对应的条件表达式为真.</p>

<p>ether proto protocol
如果数据包属于以下以太协议类型, 则与此对应的条件表达式为真.
协议(protocol)字段, 可以是数字或以下所列出了名字: ip, ip6, arp, rarp, atalk(AppleTalk网络协议),
aarp(nt: AppleTalk Address Resolution Protocol, AppleTalk网络的地址解析协议),
decnet(nt: 一个由DEC公司所提供的网络协议栈), sca(nt: 未知, 需补充),
lat(Local Area Transport, 区域传输协议, 由DEC公司开发的以太网主机互联协议),
mopdl, moprc, iso(nt: 未知, 需补充), stp(Spanning tree protocol, 生成树协议, 可用于防止网络中产生链接循环),
ipx（nt: Internetwork Packet Exchange, Novell 网络中使用的网络层协议）, 或者
netbeui(nt: NetBIOS Extended User Interface，可理解为, 网络基本输入输出系统接口扩展).</p>

<p>protocol字段可以是一个数字或以下协议名之一:ip, ip6, arp, rarp, atalk, aarp, decnet, sca, lat,
mopdl, moprc, iso, stp, ipx, 或者netbeui.
必须要注意的是标识符也是关键字, 从而必须通过&#8217;\&lsquo;来进行转义.</p>

<p>(SNAP：子网接入协议 （SubNetwork Access Protocol）)</p>

<p>在光纤分布式数据网络接口(其表达元形式可以是&#8217;fddi protocol arp&#8217;), 令牌环网(其表达元形式可以是&#8217;tr protocol arp&#8217;),
以及IEEE 802.11 无线局域网(其表达元形式可以是&#8217;wlan protocol arp&#8217;)中, protocol
标识符来自802.2 逻辑链路控制层头,
在FDDI, Token Ring 或 802.1头中会包含此逻辑链路控制层头.</p>

<p>当以这些网络上的相应的协议标识为过滤条件时, tcpdump只是检查LLC头部中以0x000000为组成单元标识符(OUI, 0x000000
标识一个内部以太网)的一段&#8217;SNAP格式结构&#8217;中的protocol ID 域, 而不会管包中是否有一段OUI为0x000000的&#8217;SNAP格式
结构&#8217;(nt: SNAP, SubNetwork Access Protocol,子网接入协议 ). 以下例外:</p>

<p>iso tcpdump 会检查LLC头部中的DSAP域(Destination service Access Point, 目标服务接入点)和
SSAP域(源服务接入点).(nt: iso 协议未知, 需补充)</p>

<p>stp 以及 netbeui
tcpdump 将会检查LLC 头部中的目标服务接入点(Destination service Access Point);</p>

<p>atalk
tcpdump 将会检查LLC 头部中以0x080007 为OUI标识的&#8217;SNAP格式结构&#8217;, 并会检查AppleTalk etype域.
(nt: AppleTalk etype 是否位于SNAP格式结构中, 未知, 需补充).</p>

<p>此外, 在以太网中, 对于ether proto protocol 选项, tcpdump 会为 protocol 所指定的协议检查
以太网类型域(the Ethernet type field), 但以下这些协议除外:</p>

<p>iso, stp, and netbeui
tcpdump 将会检查802.3 物理帧以及LLC 头(这两种检查与FDDI, TR, 802.11网络中的相应检查一致);
(nt: 802.3, 理解为IEEE 802.3, 其为一系列IEEE 标准的集合. 此集合定义了有线以太网络中的物理层以及数据
链路层的媒体接入控制子层. stp 在上文已有描述)</p>

<p>atalk
tcpdump 将会检查以太网物理帧中的AppleTalk etype 域 ,　同时也会检查数据包中LLC头部中的&#8217;SNAP格式结构&#8217;
(这两种检查与FDDI, TR, 802.11网络中的相应检查一致)</p>

<p>aarp tcpdump 将会检查AppleTalk ARP etype 域, 此域或存在于以太网物理帧中, 或存在于LLC(由802.2 所定义)的
&lsquo;SNAP格式结构&#8217;中, 当为后者时, 该&#8217;SNAP格式结构&#8217;的OUI标识为0x000000;
(nt: 802.2, 可理解为, IEEE802.2, 其中定义了逻辑链路控制层(LLC), 该层对应于OSI 网络模型中数据链路层的上层部分.
LLC 层为使用数据链路层的用户提供了一个统一的接口(通常用户是网络层). LLC层以下是媒体接入控制层(nt: MAC层,
对应于数据链路层的下层部分).该层的实现以及工作方式会根据不同物理传输媒介的不同而有所区别(比如, 以太网, 令牌环网,
光纤分布数据接口(nt: 实际可理解为一种光纤网络), 无线局域网(802.11), 等等.)</p>

<p>ipx tcpdump 将会检查物理以太帧中的IPX etype域, LLC头中的IPX DSAP域，无LLC头并对IPX进行了封装的802.3帧,
以及LLC 头部&#8217;SNAP格式结构&#8217;中的IPX etype 域(nt | rt: SNAP frame, 可理解为, LLC 头中的&#8217;SNAP格式结构&#8217;.
该含义属初步理解阶段, 需补充).</p>

<p>decnet src host
如果数据包中DECNET源地址为host, 则与此对应的条件表达式为真.
(nt:decnet, 由Digital Equipment Corporation 开发, 最早用于PDP-11 机器互联的网络协议)</p>

<p>decnet dst host
如果数据包中DECNET目的地址为host, 则与此对应的条件表达式为真.
(nt: decnet 在上文已有说明)</p>

<p>decnet host host
如果数据包中DECNET目的地址或DECNET源地址为host, 则与此对应的条件表达式为真.
(nt: decnet 在上文已有说明)</p>

<p>ifname interface
如果数据包已被标记为从指定的网络接口中接收的, 则与此对应的条件表达式为真.
(此选项只适用于被OpenBSD中pf程序做过标记的包(nt: pf, packet filter, 可理解为OpenBSD中的防火墙程序))</p>

<p>on interface
与 ifname interface 含义一致.</p>

<p>rnr num
如果数据包已被标记为匹配PF的规则, 则与此对应的条件表达式为真.
(此选项只适用于被OpenBSD中pf程序做过标记的包(nt: pf, packet filter, 可理解为OpenBSD中的防火墙程序))</p>

<p>rulenum num
与 rulenum num 含义一致.</p>

<p>reason code
如果数据包已被标记为包含PF的匹配结果代码, 则与此对应的条件表达式为真.有效的结果代码有: match, bad-offset,
fragment, short, normalize, 以及memory.
(此选项只适用于被OpenBSD中pf程序做过标记的包(nt: pf, packet filter, 可理解为OpenBSD中的防火墙程序))</p>

<p>rset name
如果数据包已被标记为匹配指定的规则集, 则与此对应的条件表达式为真.
(此选项只适用于被OpenBSD中pf程序做过标记的包(nt: pf, packet filter, 可理解为OpenBSD中的防火墙程序))</p>

<p>ruleset name
与 rset name 含义一致.</p>

<p>srnr num
如果数据包已被标记为匹配指定的规则集中的特定规则(nt: specified PF rule number, 特定规则编号, 即特定规则),
则与此对应的条件表达式为真.(此选项只适用于被OpenBSD中pf程序做过标记的包(nt: pf, packet filter, 可理解为
OpenBSD中的防火墙程序))</p>

<p>subrulenum num
与 srnr 含义一致.</p>

<p>action act
如果包被记录时PF会执行act指定的动作, 则与此对应的条件表达式为真. 有效的动作有: pass, block.
(此选项只适用于被OpenBSD中pf程序做过标记的包(nt: pf, packet filter, 可理解为OpenBSD中的防火墙程序))</p>

<p>ip, ip6, arp, rarp, atalk, aarp, decnet, iso, stp, ipx, netbeui
与以下表达元含义一致:
ether proto p
p是以上协议中的一个.</p>

<p>lat, moprc, mopdl
与以下表达元含义一致:
ether proto p
p是以上协议中的一个. 必须要注意的是tcpdump目前还不能分析这些协议.</p>

<p>vlan [vlan_id]
如果数据包为IEEE802.1Q VLAN 数据包, 则与此对应的条件表达式为真.
(nt: IEEE802.1Q VLAN, 即IEEE802.1Q 虚拟网络协议, 此协议用于不同网络的之间的互联).
如果[vlan_id] 被指定, 则只有数据包含有指定的虚拟网络id(vlan_id), 则与此对应的条件表达式为真.
要注意的是, 对于VLAN数据包, 在表达式中遇到的第一个vlan关键字会改变表达式中接下来关键字所对应数据包中数据的
开始位置(即解码偏移). 在VLAN网络体系中过滤数据包时, vlan [vlan_id]表达式可以被多次使用. 关键字vlan每出现一次都会增加
4字节过滤偏移(nt: 过滤偏移, 可理解为上面的解码偏移).</p>

<p>例如:
vlan 100 &amp;&amp; vlan 200
表示: 过滤封装在VLAN100中的VLAN200网络上的数据包
再例如:
vlan &amp;&amp; vlan 300 &amp;&amp; ip
表示: 过滤封装在VLAN300 网络中的IPv4数据包, 而VLAN300网络又被更外层的VLAN封装</p>

<p>mpls [label_num]
如果数据包为MPLS数据包, 则与此对应的条件表达式为真.
(nt: MPLS, Multi-Protocol Label Switch, 多协议标签交换, 一种在开放的通信网上利用标签引导数据传输的技术).</p>

<p>如果[label_num] 被指定, 则只有数据包含有指定的标签id(label_num), 则与此对应的条件表达式为真.
要注意的是, 对于内含MPLS信息的IP数据包(即MPLS数据包), 在表达式中遇到的第一个MPLS关键字会改变表达式中接下来关键字所对应数据包中数据的
开始位置(即解码偏移). 在MPLS网络体系中过滤数据包时, mpls [label_num]表达式可以被多次使用. 关键字mpls每出现一次都会增加
4字节过滤偏移(nt: 过滤偏移, 可理解为上面的解码偏移).</p>

<p>例如:
mpls 100000 &amp;&amp; mpls 1024
表示: 过滤外层标签为100000 而层标签为1024的数据包</p>

<p>再如:
mpls &amp;&amp; mpls 1024 &amp;&amp; host 192.9.200.1
表示: 过滤发往或来自192.9.200.1的数据包, 该数据包的内层标签为1024, 且拥有一个外层标签.</p>

<p>pppoed
如果数据包为PPP-over-Ethernet的服务器探寻数据包(nt: Discovery packet,
其ethernet type 为0x8863),则与此对应的条件表达式为真.
(nt: PPP-over-Ethernet, 点对点以太网承载协议, 其点对点的连接建立分为Discovery阶段(地址发现) 和
PPPoE 会话建立阶段 , discovery 数据包就是第一阶段发出来的包. ethernet type
是以太帧里的一个字段，用来指明应用于帧数据字段的协议)</p>

<p>pppoes
如果数据包为PPP-over-Ethernet会话数据包(nt: ethernet type 为0x8864, PPP-over-Ethernet在上文已有说明, 可搜索
关键字&#8217;PPP-over-Ethernet&#8217;找到其描述), 则与此对应的条件表达式为真.</p>

<p>要注意的是, 对于PPP-over-Ethernet会话数据包, 在表达式中遇到的第一个pppoes关键字会改变表达式中接下来关键字所对应数据包中数据的
开始位置(即解码偏移).</p>

<p>例如:
pppoes &amp;&amp; ip
表示: 过滤嵌入在PPPoE数据包中的ipv4数据包</p>

<p>tcp, udp, icmp
与以下表达元含义一致:
ip proto p or ip6 proto p
其中p 是以上协议之一(含义分别为: 如果数据包为ipv4或ipv6数据包并且其协议类型为 tcp,udp, 或icmp则与此对
应的条件表达式为真)</p>

<p>iso proto protocol
如果数据包的协议类型为iso-osi协议栈中protocol协议, 则与此对应的条件表达式为真.(nt: [初解]iso-osi 网络模型中每
层的具体协议与tcp/ip相应层采用的协议不同. iso-osi各层中的具体协议另需补充 )</p>

<p>protocol 可以是一个数字编号, 或以下名字中之一:
clnp, esis, or isis.
(nt: clnp, Connectionless Network Protocol, 这是OSI网络模型中网络层协议 , esis, isis 未知, 需补充)</p>

<p>clnp, esis, isis
是以下表达的缩写
iso proto p
其中p 是以上协议之一</p>

<p>l1, l2, iih, lsp, snp, csnp, psnp
为IS-IS PDU 类型 的缩写.
(nt: IS-IS PDU, Intermediate system to intermediate system Protocol Data Unit, 中间系统到
中间系统的协议数据单元. OSI(Open Systems Interconnection)网络由终端系统, 中间系统构成.
终端系统指路由器, 而终端系统指用户设备. 路由器形成的本地组称之为&#8217;区域&#8217;（Area）和多个区域组成一个&#8217;域&#8217;（Domain）.
IS-IS 提供域内或区域内的路由. l1, l2, iih, lsp, snp, csnp, psnp 表示PDU的类型, 具体含义另需补充)</p>

<p>vpi n
如果数据包为ATM数据包, 则与此对应的条件表达式为真. 对于Solaris 操作系统上的SunATM设备 ,
如果数据包为ATM数据包, 并且其虚拟路径标识为n, 则与此对应的条件表达式为真.
(nt: ATM, Asychronous Transfer Mode, 实际上可理解为由ITU-T(国际电信联盟电信标准化部门)提出的一个与
TCP/IP中IP层功能等同的一系列协议, 具体协议层次另需补充)</p>

<p>vci n
如果数据包为ATM数据包, 则与此对应的条件表达式为真. 对于Solaris 操作系统上的SunATM设备 ,
如果数据包为ATM数据包, 并且其虚拟通道标识为n, 则与此对应的条件表达式为真.
(nt: ATM, 在上文已有描述)</p>

<p>lane
如果数据包为ATM LANE 数据包, 则与此对应的条件表达式为真. 要注意的是, 如果是模拟以太网的LANE数据包或者
LANE逻辑单元控制包, 表达式中第一个lane关键字会改变表达式中随后条件的测试. 如果没有
指定lane关键字, 条件测试将按照数据包中内含LLC(逻辑链路层)的ATM包来进行.</p>

<p>llc
如果数据包为ATM数据包, 则与此对应的条件表达式为真. 对于Solaris 操作系统上的SunATM设备 ,
如果数据包为ATM数据包,　并且内含LLC则与此对应的条件表达式为真</p>

<p>oamf4s
如果数据包为ATM数据包, 则与此对应的条件表达式为真. 对于Solaris 操作系统上的SunATM设备 , 如果数据包为ATM数据包
并且是Segment OAM F4 信元(VPI=0 并且 VCI=3), 则与此对应的条件表达式为真.</p>

<p>(nt: OAM, Operation Administration and Maintenance, 操作管理和维护,可理解为:ATM网络中用于网络
管理所产生的ATM信元的分类方式.</p>

<p>ATM网络中传输单位为信元, 要传输的数据终究会被分割成固定长度(53字节)的信元,
(初理解: 一条物理线路可被复用, 形成虚拟路径(virtual path). 而一条虚拟路径再次被复用, 形成虚拟信道(virtual channel)).
通信双方的编址方式为:虚拟路径编号(VPI)/虚拟信道编号(VCI)).</p>

<p>OAM F4 flow 信元又可分为segment 类和end-to-end 类, 其区别未知, 需补充.)</p>

<p>oamf4e
如果数据包为ATM数据包, 则与此对应的条件表达式为真. 对于Solaris 操作系统上的SunATM设备 , 如果数据包为ATM数据包
并且是 end-to-end OAM F4 信元(VPI=0 并且 VCI=4), 则与此对应的条件表达式为真.
(nt: OAM 与 end-to-end OAM F4 在上文已有描述, 可搜索&#8217;oamf4s&#8217;来定位)</p>

<p>oamf4
如果数据包为ATM数据包, 则与此对应的条件表达式为真. 对于Solaris 操作系统上的SunATM设备 , 如果数据包为ATM数据包
并且是 end-to-end 或 segment OAM F4 信元(VPI=0 并且 VCI=3 或者 VCI=4), 则与此对应的条件表达式为真.
(nt: OAM 与 end-to-end OAM F4 在上文已有描述, 可搜索&#8217;oamf4s&#8217;来定位)</p>

<p>oam
如果数据包为ATM数据包, 则与此对应的条件表达式为真. 对于Solaris 操作系统上的SunATM设备 , 如果数据包为ATM数据包
并且是 end-to-end 或 segment OAM F4 信元(VPI=0 并且 VCI=3 或者 VCI=4), 则与此对应的条件表达式为真.
(nt: 此选项与oamf4重复, 需确认)</p>

<p>metac
如果数据包为ATM数据包, 则与此对应的条件表达式为真. 对于Solaris 操作系统上的SunATM设备 , 如果数据包为ATM数据包
并且是来自&#8217;元信令线路&#8217;(nt: VPI=0 并且 VCI=1, &lsquo;元信令线路&rsquo;, meta signaling circuit, 具体含义未知, 需补充),
则与此对应的条件表达式为真.</p>

<p>bcc
如果数据包为ATM数据包, 则与此对应的条件表达式为真. 对于Solaris 操作系统上的SunATM设备 , 如果数据包为ATM数据包
并且是来自&#8217;广播信令线路&#8217;(nt: VPI=0 并且 VCI=2, &lsquo;广播信令线路&rsquo;, broadcast signaling circuit, 具体含义未知, 需补充),
则与此对应的条件表达式为真.</p>

<p>sc
如果数据包为ATM数据包, 则与此对应的条件表达式为真. 对于Solaris 操作系统上的SunATM设备 , 如果数据包为ATM数据包
并且是来自&#8217;信令线路&#8217;(nt: VPI=0 并且 VCI=5, &lsquo;信令线路&rsquo;, signaling circuit, 具体含义未知, 需补充),
则与此对应的条件表达式为真.</p>

<p>ilmic
如果数据包为ATM数据包, 则与此对应的条件表达式为真. 对于Solaris 操作系统上的SunATM设备 , 如果数据包为ATM数据包
并且是来自&#8217;ILMI线路&#8217;(nt: VPI=0 并且 VCI=16, &lsquo;ILMI&rsquo;, Interim Local Management Interface , 可理解为
基于SNMP(简易网络管理协议)的用于网络管理的接口)
则与此对应的条件表达式为真.</p>

<p>connectmsg</p>

<p>如果数据包为ATM数据包, 则与此对应的条件表达式为真. 对于Solaris 操作系统上的SunATM设备 , 如果数据包为ATM数据包
并且是来自&#8217;信令线路&#8217;并且是Q.2931协议中规定的以下几种消息: Setup, Calling Proceeding, Connect,
Connect Ack, Release, 或者Release Done. 则与此对应的条件表达式为真.
(nt: Q.2931 为ITU(国际电信联盟)制定的信令协议. 其中规定了在宽带综合业务数字网络的用户接口层建立, 维护, 取消
网络连接的相关步骤.)</p>

<p>metaconnect
如果数据包为ATM数据包, 则与此对应的条件表达式为真. 对于Solaris 操作系统上的SunATM设备 , 如果数据包为ATM数据包
并且是来自&#8217;元信令线路&#8217;并且是Q.2931协议中规定的以下几种消息: Setup, Calling Proceeding, Connect,
Connect Ack, Release, 或者Release Done. 则与此对应的条件表达式为真.</p>

<p>expr relop expr
如果relop 两侧的操作数(expr)满足relop 指定的关系, 则与此对应的条件表达式为真.
relop 可以是以下关系操作符之一: >, &lt;, &lt;=, =, !=.
expr 是一个算术表达式. 此表达式中可使用整型常量(表示方式与标准C中一致), 二进制操作符(+, &ndash;, *, /, &amp;, |,
&lt;&lt;, >>), 长度操作符, 以及对特定数据包中数据的引用操作符. 要注意的是, 所有的比较操作都默认操作数是无符号的,
例如, 0x80000000 和 0xffffffff 都是大于0的(nt: 对于有符号的比较, 按照补码规则, 0xffffffff
会小于0). 如果要引用数据包中的数据, 可采用以下表达方式:
proto [expr : size]</p>

<p>proto 的取值可以是以下取值之一:ether, fddi, tr, wlan, ppp, slip, link, ip, arp, rarp,
tcp, udp, icmp, ip6 或者 radio. 这指明了该引用操作所对应的协议层.(ether, fddi, wlan,
tr, ppp, slip and link 对应于数据链路层, radio 对应于802.11(wlan,无线局域网)某些数据包中的附带的
&ldquo;radio&#8221;头(nt: 其中描述了波特率, 数据加密等信息)).
要注意的是, tcp, udp 等上层协议目前只能应用于网络层采用为IPv4或IPv6协议的网络(此限制会在tcpdump未来版本中
进行修改). 对于指定协议的所需数据, 其在包数据中的偏移字节由expr 来指定.</p>

<p>以上表达中size 是可选的, 用来指明我们关注那部分数据段的长度(nt:通常这段数据
是数据包的一个域)， 其长度可以是1, 2, 或4个字节. 如果不给定size, 默认是1个字节. 长度操作符的关键字为len,
这代码整个数据包的长度.</p>

<p>例如, &lsquo;ether[0] &amp; 1 != 0&rsquo; 将会使tcpdump 抓取所有多点广播数据包.(nt: ether[0]字节的最低位为1表示
数据包目的地址是多点广播地址). &lsquo;ip[0] &amp; 0xf != 5&rsquo; 对应抓取所有带有选项的
IPv4数据包. &lsquo;ip[6:2] &amp; 0x1fff = 0&#8217;对应抓取没被破碎的IPv4数据包或者
其片段编号为0的已破碎的IPv4数据包. 这种数据检查方式也适用于tcp和udp数据的引用,
即, tcp[0]对应于TCP 头中第一个字节, 而不是对应任何一个中间的字节.</p>

<p>一些偏移以及域的取值除了可以用数字也可用名字来表达. 以下为可用的一些域(协议头中的域)的名字: icmptype (指ICMP 协议头
中type域), icmpcode (指ICMP 协议头code 域), 以及tcpflags(指TCP协议头的flags 域)</p>

<p>以下为ICMP 协议头中type 域的可用取值:
icmp-echoreply, icmp-unreach, icmp-sourcequench, icmp-redirect, icmp-echo, icmp-routeradvert,
icmp-routersolicit, icmp-timx-ceed, icmp-paramprob, icmp-tstamp, icmp-tstampreply,
icmp-ireq, icmp-ireqreply, icmp-maskreq, icmp-maskreply.</p>

<p>以下为TCP 协议头中flags 域的可用取值:tcp-fin, tcp-syn, tcp-rst, tcp-push,
tcp-ack, tcp-urg.</p>

<h2>参考资料</h2>

<ol>
<li><a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html">Linux tcpdump命令详解</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【转】储性能瓶颈的成因、定位与排查]]></title>
    <link href="http://blog.longgen.me/blog/2014/07/01/cun-chu-xing-neng-ping-jing-de-cheng-yin-%2C-ding-wei-yu-pai-cha/"/>
    <updated>2014-07-01T13:13:05+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/07/01/cun-chu-xing-neng-ping-jing-de-cheng-yin-,-ding-wei-yu-pai-cha</id>
    <content type="html"><![CDATA[<p>企业数据存储性能瓶颈常常会发生在端口，控制器和磁盘，难点在于找出引起拥塞的单元，往往需要应用多重工具以及丰富的经验来查找并解决。
本文详细阐述存储瓶颈发生最常见的四种情况，可能发生的拥塞点，需要监控的参数指标，以及部署存储系统的最佳实践。</p>

<!-- more -->


<h2>数据存储瓶颈的四个常见场景</h2>

<ul>
<li>当多个用户同时访问某一业务应用，无论是邮件服务器，企业资源规划（ERP）系统或数据库，数据请求会累积在队列中。单个 I/O 的响应时间开始增长，短暂延时开始转变成为漫长的等待。</li>
</ul>


<p>这类响应时间敏感型应用的特征是，很多随机请求，读取比写入更多，I/O 较小。最好的方法是：将负载分布在多块磁盘上，否则可能造成性能瓶颈。</p>

<p>如果应用增加了更多用户，或应用IOPS请求增加，则可能需要在 RAID 组中添加更多磁盘，或数据可能需要跨越更多磁盘，在更多层级做条带化。</p>

<p>存储在这样的情况下往往首先被怀疑，但大多数情况下并非存储引发，原因可能在于网络、应用或服务器。</p>

<ul>
<li>带宽敏感型应用——如数据备份，视频流或安全登录，这类应用当多个用户同时访问大型文件或数据流时可能造成瓶颈。
定位这一问题存储管理员应当从备份服务器开始一路向下检查至磁盘，原因可能存在于这一通路的任何地方。</li>
</ul>


<p>问题不一定发生在存储，可能是由于备份应用创建的方式或是磁带系统的工作方式引起的。如果瓶颈定位于存储，那么可能是由于服务 I/O 的磁盘数量不足，在控制器造成争用，或是阵列前端口带宽不足。</p>

<p>性能调优需要针对不同应用程序负载来完成。针对大型文件和流数据的调优并不适合于小型文件，反之亦然。这也就是为什么在大多数存储系统中往往做一个平衡，需要用户尝试并找出系统的折中。用户通常需要优化吞吐量或 IOPS，但并不需要对两者同时优化。</p>

<ul>
<li>RAID 组中的磁盘故障。特别是在 RAID 5 中会造成性能的下降，因为系统需要重建校验数据。相比数据读写操作，重建会对性能造成更大影响。</li>
</ul>


<p>即便坏盘是造成故障的根源，但控制器还是可能成为瓶颈，因为在重建过程中它需要不停地服务数据。当重建完成时，性能才会恢复正常。</p>

<ul>
<li>部署了一种新的应用，而卷存在于处理繁忙邮件系统的同一磁盘。如果新的应用变得繁忙，邮件系统性能将会遭受影响。额外的流量最终会将磁盘完全覆盖。</li>
</ul>


<h2>存储瓶颈常发区域</h2>

<ul>
<li>存储区域网络（Storage-area network, SAN）/阵列前端口</li>
</ul>


<p>存储部署于集中化SAN环境时，需考虑服务器和SAN之间的潜在网络瓶颈。例如，运行多部虚拟机的整合服务器可能不具备支持工作负载要求的足够网络端口。添加网络端口或转移网络密集型工作负载至其他服务器可解决这一问题。如前所述，对于带宽集中型应用，需考虑NFS有多少Fiber Channel 端口, or iSCSI 端口 or Ethernet 端口，需要用户站在带宽的角度来考量整个架构。</p>

<p>可能发生的问题包括：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>* 如果阵列中端口数量不够，就会发生过饱和/过度使用
</span><span class='line'>* 虚拟服务器环境下的过量预定
</span><span class='line'>* 端口间负载不均衡
</span><span class='line'>* 交换机间链路争用/流量负荷过重
</span><span class='line'>* 如某一HBA端口负载过重将导致HBA拥塞。使用虚拟机会导致问题更加严重
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>存储控制器</li>
</ul>


<p>一个标准的主动——被动或主动——主动控制器都有一个性能极限。接近这条上限取决于用户有多少块磁盘，因为每块磁盘的IOPS和吞吐量是固定的。</p>

<p>可能出现的问题包括：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>* 控制器I/O过饱和，使得从缓存到阵列能够处理的IOPS受到限制
</span><span class='line'>* 吞吐量“淹没“处理器
</span><span class='line'>* CPU过载/处理器功率不足
</span><span class='line'>* 性能无法跟上SSD
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Cache</li>
</ul>


<p>由于服务器内存和CPU远比机械磁盘快得多，需为磁盘添加高速内存以缓存读写数据。例如，写入磁盘的数据存储在缓存中直到磁盘能够跟上，同时磁盘中的读数据放入缓存中直到能被主机读取。Cache比磁盘快1000倍，因此将数据写入和读出Cache对性能影响巨大。智能缓存算法能够预测你需要查找的数据，你是否会对此数据频繁访问，甚至是将访问频繁的随机数据放在缓存中。</p>

<p>可能发生的问题包括：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>* Cache memory不足
</span><span class='line'>* Cache写入过载，引起性能降低
</span><span class='line'>* 频繁访问顺序性数据引起cache超负荷
</span><span class='line'>* Cache中需要持续不断地写入新数据，因此如果cache总是在refill，将无法从cache获益
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>磁盘</li>
</ul>


<p>磁盘瓶颈与磁盘转速有关, 慢速磁盘会引入较多延时。存储性能问题的排查首先考虑的因素就是磁盘速度，同时有多少块磁盘可进行并发读写。而另一因素是磁盘接口。采用更快的接口能够缓解磁盘瓶颈，但更重要的是在快速接口与相应更大的缓存大小以及转速之间取得平衡。同样，应避免将快速和慢速磁盘混入同一接口，因为慢速磁盘将会造成快速接口与快速磁盘的性能浪费。</p>

<p>可能引发的问题包括：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>* 过多应用命中磁盘
</span><span class='line'>* 磁盘数量不足以满足应用所需的IOPS或吞吐量
</span><span class='line'>* 磁盘速度过慢无法满足性能需求及支持繁重工作负荷
</span><span class='line'>* Disk group往往是classic存储架构的潜在性能瓶颈，这种结构下RAID最多配置在16块磁盘。Thin结构通常每个LUN拥有更多磁盘，从而数据分布于更多spindle，因增加的并发性而减少了成为瓶颈的可能。
</span></code></pre></td></tr></table></div></figure>


<h2>需要监控的指标</h2>

<p>曾经一度存储厂商们强调的是IOPS和吞吐量，但现在重点逐渐转变成为响应时间。也就是说，不是数据移动的速度有多快，而在于对请求的响应速度有多快。</p>

<p>正常情况下，15,000 rpm Fibre Channel磁盘响应时间为4ms，SAS磁盘响应时间约为5ms至6ms，SATA为10ms，而SSD少于1ms。如果发现Fibre Channel磁盘响应时间为12ms，或SSD响应时间变成5ms，那么就说明可能产生了争用，可能芯片发生了故障。</p>

<p>除了响应时间，其他需要监控的指标包括：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>* 队列长度，队列中一次积累的请求数量，平均磁盘队列长度
</span><span class='line'>* 平均I/O大小千字节数
</span><span class='line'>* IOPS （读和写，随机和顺序，整体平均IOPS）
</span><span class='line'>* 每秒百万字节吞吐量
</span><span class='line'>* 读写所占比例
</span><span class='line'>* 容量（空闲，使用和保留）
</span></code></pre></td></tr></table></div></figure>


<h2>数据存储性能最佳实践</h2>

<p>性能调优和改进的方式有很多种，用户当然可以通过添加磁盘，端口，多核处理器，内存来改善，但问题是：性价比，以及对业务是否实用。本文建议的方式是在预算范围内找寻性能最大化的解决方案。另外一个需要考虑的方面是环境并非一尘不变，系统部署方案要能够适应环境的改变需求。</p>

<p>首先需要考虑刷数据的性能特征，需要了解IO工作情况是怎样的。是否是cache友好型？是否是CPU集中型？业务数据很大数量很少，还是很小但数量很多？另外一方面就是构成存储环境的组件。包括应用，存储系统本身，网络。。。瓶颈可能在哪里，改善哪里最有效？</p>

<p>以下是一些常规建议：</p>

<ol>
<li><p>不要仅仅根据空闲空间来分配存储，而需要结合考虑性能需求，确保为吞吐量或IOPS分配足够多的磁盘。</p></li>
<li><p>在磁盘间均衡分布应用负载，以减少热点地区的产生。</p></li>
<li><p>理解应用负载类型，并针对负载选择匹配的RAID类型。例如，写密集型应用建议使用RAID 1而不是RAID 5。因为当写入RAID 5时，需要计算校验位，需耗费较多时间。而RAID 1，写入两块磁盘速度快得多，无需计算。</p></li>
<li><p>磁盘类型（Fibre Channel, SAS, SATA）与期望性能相匹配。对于关键业务应用部署高性能磁盘，例如15,000 rpm Fibre Channel。</p></li>
<li><p>对于I/O密集型应用考虑采用SSD，但并不适用于写性能重要型应用。只要没有达到控制器瓶颈，SSD对读性能提升显著，但对写性能提升并没有明显效果。</p></li>
<li><p>采用端对端的监控工具，特别是虚拟服务器环境。虚拟端与物理端之间有一道防火墙，所以，需要穿透防火墙进行端到端的监控。</p></li>
<li><p>有些性能分析工具涵盖从应用到磁盘，有些仅局限于存储系统本身。由于性能是一个连锁反应包含很多变量，所以需要全面地分析数据。</p></li>
<li><p>以数据仅写入磁盘外部扇区的方式格式化磁盘。因减少数据定位时间而在高I/O环境下提升性能。负面作用是相当一部分磁盘容量未能得以使用。</p></li>
</ol>


<h2>参考资料</h2>

<ol>
<li><a href="https://community.emc.com/docs/DOC-34921">存储性能瓶颈的成因、定位与排查</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 开发常用库]]></title>
    <link href="http://blog.longgen.me/blog/2014/07/01/android-kai-fa-chang-yong-ku/"/>
    <updated>2014-07-01T11:30:43+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/07/01/android-kai-fa-chang-yong-ku</id>
    <content type="html"><![CDATA[<p>Android 开发过程中，恰当的使用一些比较成熟的库，能够大大提高开发效率。</p>

<!-- more -->


<h2>Gson</h2>

<p>Gson 是 Google 提供的用来在 Java 对象和 JSON 数据之间进行映射的 Java 类库。可用于将 Java 对象转换成对应的 JSON 表示，也可以将 JSON 字符串转换成一个等效的 Java 对象。如果与 API 打交道的话，那么这将会是你经常需要的东西。我们主要使用 JSON 的原因就是，相较 XML，轻量级的 JSON 要简单的多。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// Serialize </span>
</span><span class='line'><span class="n">String</span> <span class="n">userJSON</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Gson</span><span class="o">().</span><span class="na">toJson</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Deserialize</span>
</span><span class='line'><span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Gson</span><span class="o">().</span><span class="na">fromJson</span><span class="o">(</span><span class="n">userJSON</span><span class="o">,</span> <span class="n">User</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Retrofit</h2>

<p>就如它网站上的介绍“Retrofit 将你的 REST API 变为 Java 接口”一样，Retrofit 把 REST API 返回的数据转化为 Java 对象方便操作，对于在项目中组织 API 调用，是一个不错的解决方案。其请求方法和相对 URL 都带有注解，使得代码变得更加简洁。使用注解，你可以很容易的添加一个请求主体，操纵 URL 或头文件，并添加查询参数。除此之外，每个函数可以定义为同步或异步，具有返回值的函数为同步执行，而异步函数没有返回值且最后一个参数为 Callback 对象。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">RetrofitInterface</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// asynchronously with a callback</span>
</span><span class='line'>    <span class="nd">@GET</span><span class="o">(</span><span class="s">&quot;/api/user&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="n">User</span> <span class="nf">getUser</span><span class="o">(</span><span class="nd">@Query</span><span class="o">(</span><span class="s">&quot;user_id&quot;</span><span class="o">)</span> <span class="kt">int</span> <span class="n">userId</span><span class="o">,</span> <span class="n">Callback</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">callback</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// synchronously</span>
</span><span class='line'>    <span class="nd">@POST</span><span class="o">(</span><span class="s">&quot;/api/user/register&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="n">User</span> <span class="nf">registerUser</span><span class="o">(</span><span class="nd">@Body</span> <span class="n">User</span> <span class="n">user</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">// example</span>
</span><span class='line'><span class="n">RetrofitInterface</span> <span class="n">retrofitInterface</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RestAdapter</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
</span><span class='line'>            <span class="o">.</span><span class="na">setServer</span><span class="o">(</span><span class="n">API</span><span class="o">.</span><span class="na">API_URL</span><span class="o">).</span><span class="na">build</span><span class="o">().</span><span class="na">create</span><span class="o">(</span><span class="n">RetrofitInterface</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// fetch user with id 2048</span>
</span><span class='line'><span class="n">retrofitInterface</span><span class="o">.</span><span class="na">getUser</span><span class="o">(</span><span class="mi">2048</span><span class="o">,</span> <span class="k">new</span> <span class="n">Callback</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">success</span><span class="o">(</span><span class="n">User</span> <span class="n">user</span><span class="o">,</span> <span class="n">Response</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">failure</span><span class="o">(</span><span class="n">RetrofitError</span> <span class="n">retrofitError</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">});</span>
</span></code></pre></td></tr></table></div></figure>


<h2>EventBus</h2>

<p>EventBus 是用于简化应用中各个部件之间通信的一个库。比如从一个 Activity 发送消息到一个正在运行的服务，亦或是片段之间简单的互动。而下面使用的示例，就是如果网络连接丢失，该如何通知一个活动。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NetworkStateReceiver</span> <span class="kd">extends</span> <span class="n">BroadcastReceiver</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// post event if there is no Internet connection</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onReceive</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">,</span> <span class="n">Intent</span> <span class="n">intent</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">super</span><span class="o">.</span><span class="na">onReceive</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">intent</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">intent</span><span class="o">.</span><span class="na">getExtras</span><span class="o">()!=</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">NetworkInfo</span> <span class="n">ni</span><span class="o">=(</span><span class="n">NetworkInfo</span><span class="o">)</span> <span class="n">intent</span><span class="o">.</span><span class="na">getExtras</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="n">ConnectivityManager</span><span class="o">.</span><span class="na">EXTRA_NETWORK_INFO</span><span class="o">);</span>
</span><span class='line'>            <span class="k">if</span><span class="o">(</span><span class="n">ni</span><span class="o">!=</span><span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">ni</span><span class="o">.</span><span class="na">getState</span><span class="o">()==</span><span class="n">NetworkInfo</span><span class="o">.</span><span class="na">State</span><span class="o">.</span><span class="na">CONNECTED</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="c1">// there is Internet connection</span>
</span><span class='line'>            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">intent</span>
</span><span class='line'>                <span class="o">.</span><span class="na">getBooleanExtra</span><span class="o">(</span><span class="n">ConnectivityManager</span><span class="o">.</span><span class="na">EXTRA_NO_CONNECTIVITY</span><span class="o">,</span><span class="n">Boolean</span><span class="o">.</span><span class="na">FALSE</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                <span class="c1">// no Internet connection, send network state changed</span>
</span><span class='line'>                <span class="n">EventBus</span><span class="o">.</span><span class="na">getDefault</span><span class="o">().</span><span class="na">post</span><span class="o">(</span><span class="k">new</span> <span class="n">NetworkStateChanged</span><span class="o">(</span><span class="kc">false</span><span class="o">));</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// event</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NetworkStateChanged</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">mIsInternetConnected</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">NetworkStateChanged</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">isInternetConnected</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">mIsInternetConnected</span> <span class="o">=</span> <span class="n">isInternetConnected</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isInternetConnected</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">mIsInternetConnected</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HomeActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
</span><span class='line'>        <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_main</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">EventBus</span><span class="o">.</span><span class="na">getDefault</span><span class="o">().</span><span class="na">register</span><span class="o">(</span><span class="k">this</span><span class="o">);</span> <span class="c1">// register EventBus</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onDestroy</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">super</span><span class="o">.</span><span class="na">onDestroy</span><span class="o">();</span>
</span><span class='line'>        <span class="n">EventBus</span><span class="o">.</span><span class="na">getDefault</span><span class="o">().</span><span class="na">unregister</span><span class="o">(</span><span class="k">this</span><span class="o">);</span> <span class="c1">// unregister EventBus</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// method that will be called when someone posts an event NetworkStateChanged</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onEventMainThread</span><span class="o">(</span><span class="n">NetworkStateChanged</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">event</span><span class="o">.</span><span class="na">isInternetConnected</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Toast</span><span class="o">.</span><span class="na">makeText</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="s">&quot;No Internet connection!&quot;</span><span class="o">,</span> <span class="n">Toast</span><span class="o">.</span><span class="na">LENGTH_SHORT</span><span class="o">).</span><span class="na">show</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>ActiveAndroid</h2>

<p>ActiveAndroid 算是一个轻量级的 ORM（对象关系映射），让你无需编写一个单独的SQL语句，就可以保存和检索 SQLite 数据库记录。每个数据库记录都被包裹整齐地归为一类，如 delete（）和 save（）的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// 扩展 ActiveAndroid Model 的对象能够保存在数据库里，如：</span>
</span><span class='line'><span class="n">user</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 可以轻易替代大型 SQL 语句：</span>
</span><span class='line'><span class="n">INSERT</span> <span class="n">INTO</span> <span class="nf">Users</span> <span class="o">(</span><span class="n">Nickname</span><span class="o">,</span> <span class="n">Name</span><span class="o">,</span> <span class="n">Address</span><span class="o">,</span> <span class="n">City</span><span class="o">,</span> <span class="n">PostalCode</span><span class="o">,</span> <span class="n">Country</span><span class="o">)</span> <span class="n">VALUES</span> <span class="o">(</span><span class="err">&#39;</span><span class="n">Batman</span><span class="sc">&#39;,&#39;</span><span class="n">Bruce</span> <span class="n">W</span><span class="sc">&#39;,&#39;</span><span class="n">Palisades</span> <span class="mi">21</span><span class="sc">&#39;,&#39;</span><span class="n">Gotham</span><span class="sc">&#39;,&#39;</span><span class="mi">40000</span><span class="sc">&#39;,&#39;</span><span class="n">USA</span><span class="err">&#39;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取所有用户的例子：</span>
</span><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Select</span><span class="o">().</span><span class="na">from</span><span class="o">(</span><span class="n">User</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">execute</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 而其对应的 SQL 语句是这样：</span>
</span><span class='line'><span class="n">SELECT</span> <span class="n">Nickname</span><span class="o">,</span> <span class="n">Name</span><span class="o">,</span> <span class="n">Address</span><span class="o">,</span> <span class="n">City</span><span class="o">,</span> <span class="n">PostalCode</span><span class="o">,</span> <span class="n">Country</span> <span class="n">FROM</span> <span class="n">Users</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ActiveAndroid 是移除大量，用于和数据库一同工作的样板代码的一个很好的方法。当然除此之外，还有其他开源解决方案，如 GreenDAO 和 ORMLite。</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Universal Image Loader</h2>

<p>UIL 是是一个开源项目，其目的就是提供一个可重复使用的仪器为异步图像加载、缓存和显示。它的使用很简单：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">imageLoader</span><span class="o">.</span><span class="na">displayImage</span><span class="o">(</span><span class="n">imageUri</span><span class="o">,</span> <span class="n">imageView</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>尽管 Picasso 拥有更好的API，但其缺乏自定义。而使用 UIL 构建器几乎可以配置所有（其中最重要的就是在抓取和缓存大型图片时，Picasso 会失败）。</p>

<p>良好的开源库会让你的开发变得更简单更快速，而普遍流行的库通常测试良好且易用使用。在大多情况下，你可以很容易的将它们从 Maven 中导入到 Android Studio 项目里。将它们添加到相关性的 build.gradle 文件。并且同步之后，在你的应用里将能够很好的实现它们。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">dependencies</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">compile</span> <span class="err">&#39;</span><span class="n">com</span><span class="o">.</span><span class="na">google</span><span class="o">.</span><span class="na">code</span><span class="o">.</span><span class="na">gson</span><span class="o">:</span><span class="nl">gson:</span><span class="mf">2.2</span><span class="o">.</span><span class="mi">4</span><span class="err">&#39;</span>
</span><span class='line'>    <span class="n">compile</span> <span class="err">&#39;</span><span class="n">com</span><span class="o">.</span><span class="na">squareup</span><span class="o">.</span><span class="na">okhttp</span><span class="o">:</span><span class="nl">okhttp:</span><span class="mf">1.3</span><span class="o">.</span><span class="mi">0</span><span class="err">&#39;</span>
</span><span class='line'>    <span class="n">compile</span> <span class="err">&#39;</span><span class="n">com</span><span class="o">.</span><span class="na">squareup</span><span class="o">.</span><span class="na">retrofit</span><span class="o">:</span><span class="nl">retrofit:</span><span class="mf">1.3</span><span class="o">.</span><span class="mi">0</span><span class="err">&#39;</span>
</span><span class='line'>    <span class="n">compile</span> <span class="err">&#39;</span><span class="n">de</span><span class="o">.</span><span class="na">greenrobot</span><span class="o">:</span><span class="nl">eventbus:</span><span class="mf">2.2</span><span class="o">.+</span><span class="err">&#39;</span>
</span><span class='line'>    <span class="n">compile</span> <span class="err">&#39;</span><span class="n">com</span><span class="o">.</span><span class="na">nostra13</span><span class="o">.</span><span class="na">universalimageloader</span><span class="o">:</span><span class="n">universal</span><span class="o">-</span><span class="n">image</span><span class="o">-</span><span class="nl">loader:</span><span class="mf">1.9</span><span class="o">.</span><span class="mi">1</span><span class="err">&#39;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考资料</h2>

<ol>
<li><a href="http://www.csdn.net/article/2014-06-16/2820224-top-5-android-libraries">Android 开发者必知的 5 个开源库</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu 用户、组、权限的管理]]></title>
    <link href="http://blog.longgen.me/blog/2014/06/27/ubuntu-yong-hu-%2C-zu-%2C-quan-xian-de-guan-li/"/>
    <updated>2014-06-27T12:43:51+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/06/27/ubuntu-yong-hu-,-zu-,-quan-xian-de-guan-li</id>
    <content type="html"><![CDATA[<p>以下命令基于 Ubuntu 14.04版本。</p>

<!-- more -->


<h2>组管理</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>groups --help
</span><span class='line'>Usage: groups <span class="o">[</span>OPTION<span class="o">]</span>... <span class="o">[</span>USERNAME<span class="o">]</span>...
</span><span class='line'>Print group memberships <span class="k">for </span>each USERNAME or, <span class="k">if </span>no USERNAME is specified, <span class="k">for</span>
</span><span class='line'>the current process <span class="o">(</span>which may differ <span class="k">if </span>the groups database has changed<span class="o">)</span>.
</span><span class='line'>      --help     display this <span class="nb">help </span>and <span class="nb">exit</span>
</span><span class='line'>      --version  output version information and <span class="nb">exit</span>
</span><span class='line'>
</span><span class='line'>Report groups bugs to bug-coreutils@gnu.org
</span><span class='line'>GNU coreutils home page: &lt;http://www.gnu.org/software/coreutils/&gt;
</span><span class='line'>General <span class="nb">help </span>using GNU software: &lt;http://www.gnu.org/gethelp/&gt;
</span><span class='line'>Report groups translation bugs to &lt;http://translationproject.org/team/&gt;
</span><span class='line'>For <span class="nb">complete </span>documentation, run: info coreutils <span class="s1">&#39;groups invocation&#39;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>gpasswd --help
</span><span class='line'>Usage: gpasswd <span class="o">[</span>option<span class="o">]</span> GROUP
</span><span class='line'>
</span><span class='line'>Options:
</span><span class='line'>  -a, --add USER                add USER to GROUP
</span><span class='line'>  -d, --delete USER             remove USER from GROUP
</span><span class='line'>  -h, --help                    display this <span class="nb">help </span>message and <span class="nb">exit</span>
</span><span class='line'>  -Q, --root CHROOT_DIR         directory to chroot into
</span><span class='line'>  -r, --remove-password         remove the GROUP<span class="err">&#39;</span>s password
</span><span class='line'>  -R, --restrict                restrict access to GROUP to its members
</span><span class='line'>  -M, --members USER,...        <span class="nb">set </span>the list of members of GROUP
</span><span class='line'>  -A, --administrators ADMIN,...
</span><span class='line'>                                <span class="nb">set </span>the list of administrators <span class="k">for </span>GROUP
</span><span class='line'>Except <span class="k">for </span>the -A and -M options, the options cannot be combined.
</span></code></pre></td></tr></table></div></figure>


<h2>用户管理</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>useradd -h
</span><span class='line'>Usage: useradd <span class="o">[</span>options<span class="o">]</span> LOGIN
</span><span class='line'>       useradd -D
</span><span class='line'>       useradd -D <span class="o">[</span>options<span class="o">]</span>
</span><span class='line'>
</span><span class='line'>Options:
</span><span class='line'>  -b, --base-dir BASE_DIR       base directory <span class="k">for </span>the home directory of the
</span><span class='line'>                                new account
</span><span class='line'>  -c, --comment COMMENT         GECOS field of the new account
</span><span class='line'>  -d, --home-dir HOME_DIR       home directory of the new account
</span><span class='line'>  -D, --defaults                print or change default useradd configuration
</span><span class='line'>  -e, --expiredate EXPIRE_DATE  expiration date of the new account
</span><span class='line'>  -f, --inactive INACTIVE       password inactivity period of the new account
</span><span class='line'>  -g, --gid GROUP               name or ID of the primary group of the new
</span><span class='line'>                                account
</span><span class='line'>  -G, --groups GROUPS           list of supplementary groups of the new
</span><span class='line'>                                account
</span><span class='line'>  -h, --help                    display this <span class="nb">help </span>message and <span class="nb">exit</span>
</span><span class='line'>  -k, --skel SKEL_DIR           use this alternative skeleton directory
</span><span class='line'>  -K, --key <span class="nv">KEY</span><span class="o">=</span>VALUE           override /etc/login.defs defaults
</span><span class='line'>  -l, --no-log-init             <span class="k">do </span>not add the user to the lastlog and
</span><span class='line'>                                faillog databases
</span><span class='line'>  -m, --create-home             create the user<span class="s1">&#39;s home directory</span>
</span><span class='line'><span class="s1">  -M, --no-create-home          do not create the user&#39;</span>s home directory
</span><span class='line'>  -N, --no-user-group           <span class="k">do </span>not create a group with the same name as
</span><span class='line'>                                the user
</span><span class='line'>  -o, --non-unique              allow to create users with duplicate
</span><span class='line'>                                <span class="o">(</span>non-unique<span class="o">)</span> UID
</span><span class='line'>  -p, --password PASSWORD       encrypted password of the new account
</span><span class='line'>  -r, --system                  create a system account
</span><span class='line'>  -R, --root CHROOT_DIR         directory to chroot into
</span><span class='line'>  -s, --shell SHELL             login shell of the new account
</span><span class='line'>  -u, --uid UID                 user ID of the new account
</span><span class='line'>  -U, --user-group              create a group with the same name as the user
</span><span class='line'>  -Z, --selinux-user SEUSER     use a specific SEUSER <span class="k">for </span>the SELinux user mapping
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>adduser <span class="o">[</span>--home DIR<span class="o">]</span> <span class="o">[</span>--shell SHELL<span class="o">]</span> <span class="o">[</span>--no-create-home<span class="o">]</span> <span class="o">[</span>--uid ID<span class="o">]</span>
</span><span class='line'><span class="o">[</span>--firstuid ID<span class="o">]</span> <span class="o">[</span>--lastuid ID<span class="o">]</span> <span class="o">[</span>--gecos GECOS<span class="o">]</span> <span class="o">[</span>--ingroup GROUP | --gid ID<span class="o">]</span>
</span><span class='line'><span class="o">[</span>--disabled-password<span class="o">]</span> <span class="o">[</span>--disabled-login<span class="o">]</span> <span class="o">[</span>--encrypt-home<span class="o">]</span> USER
</span><span class='line'>   Add a normal user
</span><span class='line'>
</span><span class='line'>adduser --system <span class="o">[</span>--home DIR<span class="o">]</span> <span class="o">[</span>--shell SHELL<span class="o">]</span> <span class="o">[</span>--no-create-home<span class="o">]</span> <span class="o">[</span>--uid ID<span class="o">]</span>
</span><span class='line'><span class="o">[</span>--gecos GECOS<span class="o">]</span> <span class="o">[</span>--group | --ingroup GROUP | --gid ID<span class="o">]</span> <span class="o">[</span>--disabled-password<span class="o">]</span>
</span><span class='line'><span class="o">[</span>--disabled-login<span class="o">]</span> USER
</span><span class='line'>   Add a system user
</span><span class='line'>
</span><span class='line'>adduser --group <span class="o">[</span>--gid ID<span class="o">]</span> GROUP
</span><span class='line'>addgroup <span class="o">[</span>--gid ID<span class="o">]</span> GROUP
</span><span class='line'>   Add a user group
</span><span class='line'>
</span><span class='line'>addgroup --system <span class="o">[</span>--gid ID<span class="o">]</span> GROUP
</span><span class='line'>   Add a system group
</span><span class='line'>
</span><span class='line'>adduser USER GROUP
</span><span class='line'>   Add an existing user to an existing group
</span><span class='line'>
</span><span class='line'>general options:
</span><span class='line'>  --quiet | -q      don<span class="err">&#39;</span>t give process information to stdout
</span><span class='line'>  --force-badname   allow usernames which <span class="k">do </span>not match the
</span><span class='line'>                    NAME_REGEX<span class="o">[</span>_SYSTEM<span class="o">]</span> configuration variable
</span><span class='line'>  --help | -h       usage message
</span><span class='line'>  --version | -v    version number and copyright
</span><span class='line'>  --conf | -c FILE  use FILE as configuration file
</span></code></pre></td></tr></table></div></figure>


<h2>密码管理</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>passwd --help
</span><span class='line'>Usage: passwd <span class="o">[</span>options<span class="o">]</span> <span class="o">[</span>LOGIN<span class="o">]</span>
</span><span class='line'>
</span><span class='line'>Options:
</span><span class='line'>  -a, --all                     report password status on all accounts
</span><span class='line'>  -d, --delete                  delete the password <span class="k">for </span>the named account
</span><span class='line'>  -e, --expire                  force expire the password <span class="k">for </span>the named account
</span><span class='line'>  -h, --help                    display this <span class="nb">help </span>message and <span class="nb">exit</span>
</span><span class='line'>  -k, --keep-tokens             change password only <span class="k">if </span>expired
</span><span class='line'>  -i, --inactive INACTIVE       <span class="nb">set </span>password inactive after expiration
</span><span class='line'>                                to INACTIVE
</span><span class='line'>  -l, --lock                    lock the password of the named account
</span><span class='line'>  -n, --mindays MIN_DAYS        <span class="nb">set </span>minimum number of days before password
</span><span class='line'>                                change to MIN_DAYS
</span><span class='line'>  -q, --quiet                   quiet mode
</span><span class='line'>  -r, --repository REPOSITORY   change password in REPOSITORY repository
</span><span class='line'>  -R, --root CHROOT_DIR         directory to chroot into
</span><span class='line'>  -S, --status                  report password status on the named account
</span><span class='line'>  -u, --unlock                  unlock the password of the named account
</span><span class='line'>  -w, --warndays WARN_DAYS      <span class="nb">set </span>expiration warning days to WARN_DAYS
</span><span class='line'>  -x, --maxdays MAX_DAYS        <span class="nb">set </span>maximum number of days before password
</span><span class='line'>                                change to MAX_DAYS
</span></code></pre></td></tr></table></div></figure>


<h2>文件相关</h2>

<ul>
<li><code>/etc/group</code>：用户组的配置文件，包括用户和用户组信息</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 每条记录包含四项内容，以分号隔开</span>
</span><span class='line'>1. 用户组名称
</span><span class='line'>2. 用户组密码，<span class="sb">`</span>x<span class="sb">`</span>值表示未设置密码
</span><span class='line'>3. GID，用户组 ID
</span><span class='line'>4. 用户列表，多个用户之间以逗号分隔；字段为空表示 GID 值为本用户组 GID 值的用户（可以通过<span class="sb">`</span>/etc/passwd<span class="sb">`</span>查看）
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>/etc/shadow</code>：</li>
<li><code>/etc/passwd</code>：用户信息配置文件</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu SSH 服务开启]]></title>
    <link href="http://blog.longgen.me/blog/2014/06/27/ubuntu-ssh-fu-wu-kai-qi/"/>
    <updated>2014-06-27T12:31:02+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/06/27/ubuntu-ssh-fu-wu-kai-qi</id>
    <content type="html"><![CDATA[<h2>开启 SSH 服务</h2>

<ul>
<li>openssh-client，客户端，用于登陆其他服务器，ubuntu 默认已经安装，如果未安装则执行以下命令：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>sudo apt-get install openssh-client
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>openssh-server，服务端，本机对外开放 SSH 服务</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 安装 openssh-server</span>
</span><span class='line'>sudo apt-get install openssh-server
</span><span class='line'>
</span><span class='line'><span class="c"># 确认 ssh server 是否启动，sshd 表示 ssh server 启动成功</span>
</span><span class='line'>ps -e | grep ssh
</span><span class='line'>
</span><span class='line'><span class="c"># 启动 ssh server 服务，ssh server 的配置文件位于 `/etc/ssh/sshd_config`，在这里可以定义 SSH 的服务端口，默认为22</span>
</span><span class='line'>sudo /etc/init.d/ssh start
</span><span class='line'><span class="c"># 或</span>
</span><span class='line'>service ssh start
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu 软件安装与卸载]]></title>
    <link href="http://blog.longgen.me/blog/2014/06/27/ubuntu-ruan-jian-an-zhuang-yu-xie-zai/"/>
    <updated>2014-06-27T11:56:37+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/06/27/ubuntu-ruan-jian-an-zhuang-yu-xie-zai</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>软件包的安装、卸载</h2>

<h3>软件包的安装</h3>

<ul>
<li>APT 方式</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 普通安装</span>
</span><span class='line'>apt-get install softname1 softname2 ...;
</span><span class='line'>
</span><span class='line'><span class="c"># 修复安装（-f Atemp to correct broken dependencies）</span>
</span><span class='line'>apt-get -f install softname1 softname2 ...;
</span><span class='line'>
</span><span class='line'><span class="c"># 重新安装</span>
</span><span class='line'>apt-get --reinstall install softname1 softname2 ...;
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Dpkg 方式</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 普通安装</span>
</span><span class='line'>dpkg -i package_name.deb
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>源码安装（.tar、tar.gz、tar.bz2、tar.Z）</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 首先解压源码压缩包，通过 tar 命令来完成</span>
</span><span class='line'>tar zxf xx.tar.gz
</span><span class='line'>tar zxf xx.tar.Z
</span><span class='line'>tar zxf xx.tgz
</span><span class='line'>bunzip2 xx.bz2
</span><span class='line'>tar xf xx.tar
</span><span class='line'>
</span><span class='line'><span class="c"># 进入到解压出的目录中，查看README之类的说明文件，或使用`ls -F --color`或`ls -F`命令查看下可执行文件，可执行文件会以*号的尾部标识。一般依次执行一下操作即可完成安装：</span>
</span><span class='line'>./configure
</span><span class='line'>make
</span><span class='line'>sudo make install
</span></code></pre></td></tr></table></div></figure>


<h3>软件包的卸载</h3>

<ul>
<li>APT 方式</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 移除式卸载（移除软件包，当尾部有+时，表示安装）</span>
</span><span class='line'>apt-get remove softname1 softname2 ...;
</span><span class='line'>
</span><span class='line'><span class="c"># 清除式卸载（卸载同时，清除配置）</span>
</span><span class='line'>apt-get --purge remove softname1 softname2 ...;
</span><span class='line'>
</span><span class='line'><span class="c"># 清除式卸载（卸载同时，清除配置）</span>
</span><span class='line'>apt-get purge softname1 softname2 ...;
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Dpkg 方式</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 移除式卸载</span>
</span><span class='line'>dpkg -r pkg1 pkg2 ...;
</span><span class='line'>
</span><span class='line'><span class="c"># 清除式卸载</span>
</span><span class='line'>dpkg -P pkg1 pkg2 ...;
</span></code></pre></td></tr></table></div></figure>


<h2>查看是否安装某软件包</h2>

<ul>
<li>Dpkg 使用文本文件来作为数据库，通常在<code>/var/lib/dpkg</code>目录下。通常在<code>status</code>文件中存储软件状态和控制信息，在<code>info/</code>目录下备份控制文件，并在其下的<code>.list</code>文件中记录安装文件清单，其下<code>.md5sums</code>保存文件的 MD5 编码。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>dpkg -l
</span><span class='line'><span class="nv">Desired</span><span class="o">=</span>Unknown/Install/Remove/Purge/Hold
</span><span class='line'>| <span class="nv">Status</span><span class="o">=</span>Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
</span><span class='line'>|/ Err?<span class="o">=(</span>none<span class="o">)</span>/Reinst-required <span class="o">(</span>Status,Err: <span class="nv">uppercase</span><span class="o">=</span>bad<span class="o">)</span>
</span><span class='line'><span class="o">||</span>/ Name                                   Version                  Architecture             Description
</span><span class='line'>+++-<span class="o">======================================</span>-<span class="o">========================</span>-<span class="o">========================</span>-<span class="o">==================================================================================</span>
</span><span class='line'>ii  account-plugin-aim                     3.8.6-0ubuntu9           amd64                    Messaging account plugin <span class="k">for </span>AIM
</span><span class='line'>ii  account-plugin-facebook                0.11+14.04.20140409.1-0u all                      GNOME Control Center account plugin <span class="k">for </span>single signon - facebook
</span><span class='line'>ii  account-plugin-flickr                  0.11+14.04.20140409.1-0u all                      GNOME Control Center account plugin <span class="k">for </span>single signon - flickr
</span><span class='line'>ii  account-plugin-google                  0.11+14.04.20140409.1-0u all                      GNOME Control Center account plugin <span class="k">for </span>single signon
</span><span class='line'>ii  account-plugin-jabber                  3.8.6-0ubuntu9           amd64                    Messaging account plugin <span class="k">for </span>Jabber/XMPP
</span><span class='line'>......
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>以上每条记录对应一个软件包，每条记录前三个字符表示软件包的状态标识，后边依次是软件包名称、版本号和简单描述</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 第一个字符为期望值，它包括：</span>
</span><span class='line'>
</span><span class='line'>    * u 状态未知，这意味着软件包未安装，并且用户也未发出安装请求
</span><span class='line'>    * i 用户请求安装软件包
</span><span class='line'>    * r 用户请求卸载软件包
</span><span class='line'>    * p 用户请求清除软件包
</span><span class='line'>    * h 用户请求保持软件包版本锁定
</span><span class='line'>
</span><span class='line'><span class="c"># 第二个字符为软件包当前状态，包括：</span>
</span><span class='line'>
</span><span class='line'>    * n 软件包未安装
</span><span class='line'>    * i 软件包安装并完成配置
</span><span class='line'>    * c 软件包以前安装过，现在删除了，但是它的配置文件还留在系统中
</span><span class='line'>    * u 软件包被解包，但还未配置
</span><span class='line'>    * f 试图配置软件包，但是失败了
</span><span class='line'>    * h 软件包安装，但是没有安装成功
</span><span class='line'>
</span><span class='line'><span class="c"># 第三个字符为错误状态，包括</span>
</span><span class='line'>
</span><span class='line'>    * 空 表示没有问题
</span><span class='line'>    * h 软件包被强制保持，因为有其他软件包依赖需求，无法升级
</span><span class='line'>    * r 软件包被破坏，可能需要重新安装才能正常使用（包括删除）
</span><span class='line'>    * x 软件包被破坏，并且被强制保持
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>其他查询方式</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 通配符模糊查询</span>
</span><span class='line'>dpkg -l nano*
</span><span class='line'>
</span><span class='line'><span class="c"># 查询系统中属于 nano 的文件</span>
</span><span class='line'>dpkg --listfiles nano
</span><span class='line'><span class="c"># 或</span>
</span><span class='line'>dpkg-query -L nano
</span><span class='line'>
</span><span class='line'><span class="c"># 查看软件nano的详细信息</span>
</span><span class='line'>dpkg -s nano
</span><span class='line'><span class="c"># 或</span>
</span><span class='line'>dpkg-query -s nano
</span><span class='line'>
</span><span class='line'><span class="c"># 查看系统中软件包状态，支持模糊查询</span>
</span><span class='line'>dpkg -l
</span><span class='line'><span class="c"># 或</span>
</span><span class='line'>dpkg-query -l
</span><span class='line'>
</span><span class='line'><span class="c"># 查看某个文件的归属包</span>
</span><span class='line'>dpkg -S nano
</span><span class='line'><span class="c"># 或</span>
</span><span class='line'>dpkg-query -S nano
</span></code></pre></td></tr></table></div></figure>


<h2>其他命令</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>apt-cache search <span class="c"># package 搜索包</span>
</span><span class='line'>apt-cache show <span class="c"># package 获取包的相关信息，如说明、大小、版本等</span>
</span><span class='line'>apt-get install <span class="c"># package 安装包，下载软件包及其所有的依赖包，同时进行包的安装或升级。如果某个包被设置了 hold，将不会被升级</span>
</span><span class='line'>apt-get --reinstall install <span class="c"># package --reinstall 重新安装包</span>
</span><span class='line'>apt-get -f install <span class="c"># package 强制安装，-f 即 --fix-missing</span>
</span><span class='line'>apt-get remove <span class="c"># package 删除包以及任何依赖这个包的其他包</span>
</span><span class='line'>apt-get remove --purge <span class="c"># package 删除包，同时删除配置文件等</span>
</span><span class='line'>apt-get autoremove --purge <span class="c"># package 删除包及其依赖的软件包和配置文件等，只对6.10有效</span>
</span><span class='line'>apt-get update <span class="c"># 更新源</span>
</span><span class='line'>apt-get upgrade <span class="c"># 更新已安装的包为最新可用版本，不会安装新的或移除老的包，如果一个包改变了依赖关系而需要安装一个新的包，那么它将不会被升级，而是标识为 hold。建议同时使用 -u 选项，能看到哪些包将会被升级</span>
</span><span class='line'>apt-get dist-upgrade <span class="c"># 升级系统，和 apt-get upgrade 类似，但是会安装和移除包来满足依赖关系，具有一定危险性</span>
</span><span class='line'>apt-get dselect-upgrade <span class="c"># 使用 dselect 升级</span>
</span><span class='line'>apt-cache depends <span class="c"># package 了解使用依赖</span>
</span><span class='line'>apt-cache rdepends <span class="c"># package 了解某个具体的依赖，查看该包被哪些包依赖</span>
</span><span class='line'>apt-cache showpkg <span class="c"># 显示 package 更多信息以及和其他包的关系</span>
</span><span class='line'>apt-get build-dep <span class="c"># package 安装相关的编译环境</span>
</span><span class='line'>apt-get <span class="nb">source</span> <span class="c"># package 下载该包的源码</span>
</span><span class='line'>apt-get clean <span class="c"># 清理下载文件的存档</span>
</span><span class='line'>apt-get autoclean <span class="c"># 只清理过时的包</span>
</span><span class='line'>apt-get check <span class="c"># 检查是否有损坏的依赖</span>
</span><span class='line'>dpkg -S filename <span class="c"># 查找 filename 属于哪个软件包</span>
</span><span class='line'>apt-file search filename <span class="c"># 查找 filename 属于哪个软件包</span>
</span><span class='line'>apt-file list packagename <span class="c"># 列出软件包的内容</span>
</span><span class='line'>apt-file update <span class="c"># 更新 apt-file 的数据库</span>
</span><span class='line'>
</span><span class='line'>dpkg --info packagename <span class="c"># 列出软件包解包后的包名称</span>
</span><span class='line'>dpkg -l <span class="c">## 列出当前系统中所有的包，可以和参数 less 一起使用在分屏查看（类似于 rpm -qa）</span>
</span><span class='line'>dpkg -l | grep -i packagename <span class="c"># 查看系统中与 packagename 相关联得包</span>
</span><span class='line'>dpkg -s <span class="c"># 查询已经安装的包的详细信息</span>
</span><span class='line'>dpkg -L <span class="c"># 查询系统中已安装的软件包所安装的位置（类似于 rpm -ql）</span>
</span><span class='line'>dpkg -S <span class="c"># 查询系统中某个文件属于哪个软件包（类似于 rpm -qf）</span>
</span><span class='line'>dpkg -I <span class="c"># 查询 deb 包的详细信息，在一个软件包下载到本地之后看看是否需要安装</span>
</span><span class='line'>dpkg -i <span class="c"># 手动安装软件包（这个命令不能解决软件包之前的依赖性问题），如果在安装某一个软件包的时候遇到了软件依赖的问题，可以用 apt-get -f install 在解决依赖性问题</span>
</span><span class='line'>dpkg -r <span class="c"># 卸载软件包，不是完全的卸载，它的配置文件还在</span>
</span><span class='line'>dpkg -P <span class="c"># 全部卸载（但是还是不能解决软件包的依赖性问题）</span>
</span><span class='line'>dpkg -reconfigure <span class="c"># 重新配置</span>
</span><span class='line'>dpkg-reconfigure --frontend<span class="o">=</span>dialog debconf <span class="c"># 如果安装时选错了，可以改回来</span>
</span><span class='line'>dpkg -c <span class="c"># 列出内容</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考资料</h2>

<ol>
<li><a href="http://www.cnblogs.com/forward/archive/2012/01/10/2318483.html">ubuntu 安装和查看已安装</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Analytics 在页面中的使用]]></title>
    <link href="http://blog.longgen.me/blog/2014/06/23/google-analytics-zai-ye-mian-zhong-de-shi-yong/"/>
    <updated>2014-06-23T09:17:10+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/06/23/google-analytics-zai-ye-mian-zhong-de-shi-yong</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eclipse 配置及优化]]></title>
    <link href="http://blog.longgen.me/blog/2014/04/30/eclipse-pei-zhi-you-hua/"/>
    <updated>2014-04-30T17:34:25+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/04/30/eclipse-pei-zhi-you-hua</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>Windows 环境配置</h2>

<ol>
<li>HOME</li>
<li>JAVA_HOME</li>
<li>PATH</li>
</ol>


<h2>eclipse 插件配置</h2>

<ol>
<li>安装 Eclipse Color Theme 插件，配置编辑器样式</li>
<li>StartExplorer，跨平台的 eclipse 快捷打开文件所在文件夹的插件</li>
<li>Subversive &ndash; SVN Team Provider 插件，</li>
<li>Enide Studio 插件，Node.js，JavaScript 等开发插件</li>
<li>UML Designer (Eclipse Kepler version) 3.0，UML 设计插件</li>
</ol>


<h2>eclipse 加速</h2>

<ol>
<li>validation 中，关闭 build 下的所有校验（可以保留Classpath Dependency Validator），只开启 manual 手工校验</li>
<li>Plug-in Development > Target Platform > plug-in 中关闭无关或暂且不用的 plug-in</li>
<li>Preferences > General > Startup and Shutdown 取消无关或暂且不用的 plug-ins</li>
<li>将 Preferences 中的 Dashboard 调整为不随 eclipse 启动</li>
</ol>


<h2>编码配置</h2>

<ol>
<li>Preferences > General > Workspace 中 Text file encoding 改为 UTF-8</li>
<li>Preferences > General > Content Types 中更改 Text 下的 Java Properties File、Java Source File、Javascript Source File、JSP 为 UTF-8，其余 content types 的编码可以根据需要进行调整</li>
</ol>


<h2>字体设置</h2>

<ol>
<li>Preferences > General > Appearance > Colors and Fonts 中 更改 Basic 下的 Text Font，建议字体：Consolas、Courier new、Inconsolata，脚本改为：中欧字符</li>
</ol>


<h2>快捷键设置</h2>

<ol>
<li>Preferences > General > Keys 中 Content Assist 快捷键更改为 alt + /</li>
</ol>


<h2>标签装饰</h2>

<ol>
<li>Preferences > General > Appearance > Label Decorations 设置各种标签装饰</li>
</ol>


<h2>Console 输出</h2>

<ol>
<li>Preferences > Run/Debug > Console 设置 Console buffer size(characters) 为 800000</li>
</ol>


<h2>编辑区配置</h2>

<ol>
<li>Preferences > General > Editors > Text Editors （或者在文件编辑区域左侧边，点击右键），勾选 Show Line Numbers 开启行号显示</li>
</ol>


<h2>拼写检查</h2>

<ol>
<li>Preferences > General > Editors > Text Editors > Spelling 中取消勾选 Enable spell checking，关闭拼写检查</li>
</ol>


<h2>代码风格及代码模板</h2>

<ol>
<li>Preferences > Java > Code Style > Formatter 中配置 Java 代码风格</li>
<li>Preferences > Java > Code Style > Code Templates 中勾选 Automatically add comments for new methods and types 开启 comments</li>
<li>Preferences > Java > Editor > Templates 中配置代码模板</li>
</ol>


<h2>常见警告解决办法</h2>

<ul>
<li>git 工具未安装：安装 git <a href="http://git-scm.com/">http://git-scm.com/</a> 工具，按说明配置 System Settings；或者取消警告消息</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 错误消息</span>
</span><span class='line'>EGit couldn<span class="s1">&#39;t detect the installation path &quot;gitPrefix&quot; of native Git. Hence EGit can&#39;</span>t respect system level Git settings which might be configured in <span class="k">${</span><span class="nv">gitPrefix</span><span class="k">}</span>/etc/gitconfig under the native Git installation directory. The most important of these settings is core.autocrlf. Git <span class="k">for </span>Windows by default sets this parameter to <span class="nb">true </span>in this system level configuration. The Git installation location can be configured on the Team &gt; Git &gt; Configuration preference page<span class="s1">&#39;s &#39;</span>System Settings<span class="err">&#39;</span> tab. This warning can be switched off on the Team &gt; Git &gt; Confirmations and Warnings preference page.
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>HOME 环境变量未设置：设置 HOME 环境变量；或者取消告警消息</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 错误消息</span>
</span><span class='line'>Warning: The environment variable HOME is not set. The following directory will be used to store the Git
</span><span class='line'>user global configuration and to define the default location to store repositories: <span class="s1">&#39;C:\Documents and Settings\Wizard&#39;</span>. If this is
</span><span class='line'>not correct please <span class="nb">set </span>the HOME environment variable and restart Eclipse. Otherwise Git <span class="k">for </span>Windows and
</span><span class='line'>EGit might behave differently since they see different configuration options.
</span><span class='line'>This warning can be switched off on the Team &gt; Git &gt; Confirmations and Warnings preference page.
</span></code></pre></td></tr></table></div></figure>


<h2>常见错误解决办法</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu 11.04 下使用 Nexus 搭建 Maven 仓库]]></title>
    <link href="http://blog.longgen.me/blog/2014/04/30/ubuntu-11-dot-04-xia-shi-yong-nexus-da-jian-maven-cang-ku/"/>
    <updated>2014-04-30T10:03:33+08:00</updated>
    <id>http://blog.longgen.me/blog/2014/04/30/ubuntu-11-dot-04-xia-shi-yong-nexus-da-jian-maven-cang-ku</id>
    <content type="html"><![CDATA[<h2>仓库管理器优点</h2>

<ol>
<li>时间及带宽的节省，加速组织内部项目构建。</li>
<li>可控制 Maven 下载的机制，为组织的总体架构和政策实施提供了依赖方面的控制（例如，避免不小心添加 GPL 许可证的依赖等等）。</li>
<li>为开发人员和部门之间提供一种共享内部项目构件的快照版本和发布版本的机制，避免组织内的每个成员单独下载并构建各自的内部项目。</li>
</ol>


<!-- more -->


<h2>Java 下载及安装</h2>

<ol>
<li>根据需求，在 <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a> 下载对应 JDK 版本。或者通过 wget 命令将下载中的 JDK 链接地址通过命令行下载。</li>
<li>将 JDK 压缩包复制至指定目录，解压 JDK 压缩包，并配置环境变量。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 创建 Java JDK 目标目录</span>
</span><span class='line'>sudo mkdir -p /usr/lib/java
</span><span class='line'>
</span><span class='line'><span class="c"># 将 JDK 压缩包复制至 /usr/lib/java 目录</span>
</span><span class='line'>sudo cp jdk-7u55-linux-x64.tar.gz /usr/lib/java
</span><span class='line'>
</span><span class='line'><span class="c"># 解压 JDK</span>
</span><span class='line'><span class="nb">cd</span> /usr/lib/java
</span><span class='line'>sudo tar zxvf jdk-7u55-linux-x64.tar.gz
</span><span class='line'>
</span><span class='line'><span class="c"># 给当前用户赋予可执行权限</span>
</span><span class='line'>sudo chmod u+x jdk1.7.0_55
</span><span class='line'>
</span><span class='line'><span class="c"># Windows 下可以采用 gedit 编辑器（或其他编辑器）配置环境变量</span>
</span><span class='line'>sudo gedit /etc/profile
</span><span class='line'><span class="c"># 或类 Unix 环境下，采用 nano 或 vi 等编辑器配置环境变量</span>
</span><span class='line'>sudo nano /etc/profile
</span><span class='line'><span class="c"># 将如下内容添加至文件中，保存并关闭文件</span>
</span><span class='line'>    <span class="c"># JDK environment</span>
</span><span class='line'>    <span class="nb">export </span><span class="nv">JAVA_HOME</span><span class="o">=</span>/usr/lib/java/jdk1.7.0_55
</span><span class='line'>    <span class="nb">export </span><span class="nv">JRE_HOME</span><span class="o">=</span><span class="nv">$JAVA_HOME</span>/jre
</span><span class='line'>    <span class="nb">export </span><span class="nv">CLASSPATH</span><span class="o">=</span>.:<span class="nv">$JAVA_HOME</span>/lib:<span class="nv">$JRE_HOME</span>/lib
</span><span class='line'>    <span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$JAVA_HOME</span>/bin:<span class="nv">$JRE_HOME</span>/bin:<span class="nv">$PATH</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 重新登陆使配置生效，或执行以下命令使配置生效</span>
</span><span class='line'><span class="nb">source</span> /etc/profile
</span><span class='line'>
</span><span class='line'><span class="c"># 测试 JAVA 版本</span>
</span><span class='line'>java -version
</span></code></pre></td></tr></table></div></figure>


<h2>Nexus 下载及安装</h2>

<p>进入 <a href="http://www.sonatype.org/nexus/archived">Nexus 下载页面</a>，下载安装 Nexus，并配置环境。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 下载 nexus oss（nexus pro 收费）当前版本 2.8.0</span>
</span><span class='line'>wget http://www.sonatype.org/downloads/nexus-latest-bundle.zip
</span><span class='line'>
</span><span class='line'><span class="c"># 复制至/usr/lcoal</span>
</span><span class='line'>sudo cp nexus-latest-bundle.zip /usr/local
</span><span class='line'>
</span><span class='line'><span class="c"># 解压</span>
</span><span class='line'>unzip nexus-latest-bundle.zip
</span><span class='line'>
</span><span class='line'><span class="c"># 创建软连接</span>
</span><span class='line'>ln -s nexus-2.8.0-05 nexus
</span><span class='line'>
</span><span class='line'><span class="c"># 编辑 /etc/profile 文件，配置 Nexus 环境</span>
</span><span class='line'>sudo vi /etc/profile
</span><span class='line'><span class="c"># 在文件中加入如下内容</span>
</span><span class='line'>    <span class="c"># Nexus environment</span>
</span><span class='line'>    <span class="nb">export </span><span class="nv">NEXUS_HOME</span><span class="o">=</span>/usr/local/nexus
</span><span class='line'>
</span><span class='line'><span class="c"># 重新登陆，或执行以下命令使配置生效</span>
</span><span class='line'><span class="nb">source</span> /etc/profile
</span><span class='line'>
</span><span class='line'><span class="c"># 为 nexus-2.8.0_05 及 sonatype-work 赋权</span>
</span><span class='line'>sudo chmod -R a+rwx nexus-2.8.0_05
</span><span class='line'>sudo chmod -R a+rwx sonatype-work
</span></code></pre></td></tr></table></div></figure>


<h2>启动 Nexus</h2>

<p>简单启动 nexus</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># console 启动</span>
</span><span class='line'><span class="nb">cd</span> /usr/local/nexus
</span><span class='line'>./bin/nexus console
</span><span class='line'>
</span><span class='line'><span class="c"># 后台启动</span>
</span><span class='line'>./bin/nexus start
</span><span class='line'><span class="c"># 查看日志</span>
</span><span class='line'>tail -f logs/wrapper.log
</span></code></pre></td></tr></table></div></figure>


<p>以服务启动 nexus</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 假设 nexus 用户具有运行 nexus 服务的权限</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 复制 $NEXUS_HOME/bin/nexus 到 /etc/init.d/nexus，或创建一个symlink</span>
</span><span class='line'>sudo ln -s <span class="nv">$NEXUS_HOME</span>/bin/nexus /etc/init.d/nexus
</span><span class='line'>
</span><span class='line'><span class="c"># 给/etc/init.d/nexus 脚本赋可执行权限</span>
</span><span class='line'>chmod 755 /etc/init.d/nexus
</span><span class='line'>
</span><span class='line'><span class="c"># 更改 /etc/init.d/nexus 脚本中的内容</span>
</span><span class='line'>    1. 设置 <span class="nv">NEXUS_HOME</span><span class="o">=</span><span class="s2">&quot;/usr/local/nexus&quot;</span>
</span><span class='line'>    2. 设置 <span class="nv">RUN_AS_USER</span><span class="o">=</span>nexus 或其他具有权限的用户来执行 Nexus 服务，避免使用 root 来运行 Nexus 服务
</span><span class='line'>    3.
</span></code></pre></td></tr></table></div></figure>


<h2>参考资料</h2>

<ul>
<li><a href="http://books.sonatype.com/nexus-book/reference/index.html">Repository Management with Nexus</a></li>
<li><a href="http://books.sonatype.com/nexus-book/reference/install-sect-service.html">Configuring Nexus as a Service</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
